<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4D36DBYDJX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-4D36DBYDJX');
    </script>
    <title>unitale aiå·¥å…·</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        .thinking {
            color: #6b7280;
            font-style: italic;
            background: #f3f4f6;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            border-left: 4px solid #d1d5db;
            font-size: 0.9rem;
        }

        .result-box {
            line-height: 1.6;
            font-size: 1rem;
            color: #1f2937;
        }

        /* éšæœºèƒŒæ™¯ä¸æ¯›ç»ç’ƒç‰¹æ•ˆ */
        body {
            background-color: #f1f5f9;
            /* Fallback color */
            background-image: url('https://picsum.photos/1920/1080');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }

        #app {
            background-color: rgba(255, 255, 255, 0.75) !important;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        /* å†…éƒ¨ç»„ä»¶åŠé€æ˜åŒ–ï¼Œå¢å¼ºå±‚æ¬¡æ„Ÿ */
        #app .bg-white,
        #app .bg-slate-50,
        #app .bg-slate-100 {
            background-color: rgba(255, 255, 255, 0.5) !important;
        }

        input,
        textarea,
        select {
            background-color: rgba(255, 255, 255, 0.8) !important;
        }
    </style>
</head>

<body class="p-4 md:p-8">
    <div id="app" class="w-full max-w-[96%] mx-auto p-6 rounded-2xl shadow-2xl">
        <header class="mb-6 flex justify-between items-end">
            <div>
                <h1 class="text-2xl font-bold text-slate-800">Unitale AI <span class="text-blue-600">1.4</span></h1>
                <p style="color: rgb(39, 92, 120);" class="text-slate-400 text-xs mt-1">å¤šè§’è‰²éŸ³æ•ˆåˆæˆæœ‰å£°ä¹¦ç”Ÿæˆå·¥å…·</p>
            </div>
            <div class="text-[10px] text-slate-300">v1.4</div>
        </header>

        <!-- æ ‡ç­¾é¡µå¯¼èˆª -->
        <div class="flex border-b border-slate-200 mb-6">
            <button @click="activeTab = 'config'"
                :class="['px-6 py-3 text-sm font-bold transition-colors', activeTab === 'config' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700']">
                æ¨¡å‹é…ç½®
            </button>
            <button @click="activeTab = 'timbres'"
                :class="['px-6 py-3 text-sm font-bold transition-colors', activeTab === 'timbres' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700']">
                éŸ³è‰²èµ„æºåº“
            </button>
            <button @click="activeTab = 'sfx'"
                :class="['px-6 py-3 text-sm font-bold transition-colors', activeTab === 'sfx' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700']">
                éŸ³æ•ˆä¸æ»¤æ³¢å™¨
            </button>
            <button @click="activeTab = 'script'"
                :class="['px-6 py-3 text-sm font-bold transition-colors', activeTab === 'script' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700']">
                è„šæœ¬åˆ¶ä½œ
            </button>
            <button @click="activeTab = 'prompt'"
                :class="['px-6 py-3 text-sm font-bold transition-colors', activeTab === 'prompt' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700']">
                Prompt ç®¡ç†
            </button>
        </div>

        <!-- é¡µé¢ 1: æ¨¡å‹é…ç½® (LLM & TTS) -->
        <div v-if="activeTab === 'config'" class="space-y-6">
            <h2 class="text-lg font-bold text-slate-800 border-b pb-2">LLM æ¨¡å‹é…ç½®ï¼ˆOpenAIé€šç”¨æ¥å£ï¼‰</h2>
            <!-- æ·»åŠ /ç¼–è¾‘è¡¨å• -->
            <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditing ? 'ç¼–è¾‘é…ç½®' : 'æ·»åŠ æ–°é…ç½®' }}</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">é…ç½®åç§°</label>
                        <input v-model="form.name"
                            class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                            placeholder="ä¾‹å¦‚: Google Gemini">
                    </div>
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">æ¨¡å‹åç§°</label>
                        <input v-model="form.model"
                            class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                            placeholder="gemini-2.5-flash">
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">Base URL</label>
                        <input v-model="form.baseUrl"
                            class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                            placeholder="https://generativelanguage.googleapis.com/v1beta/openai">
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">API Key</label>
                        <input v-model="form.key" type="password"
                            class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                            placeholder="sk-...">
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">é¢å¤–å‚æ•°
                            (JSONæ ¼å¼ï¼Œå¯é€‰)</label>
                        <input v-model="form.params"
                            class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                            placeholder='ä¾‹å¦‚: {"temperature": 0.7, "max_tokens": 2000}'>
                    </div>
                </div>
                <div class="flex gap-2">
                    <button type="button" @click.prevent="saveConfig"
                        class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">ä¿å­˜é…ç½®</button>
                    <button type="button" v-if="isEditing" @click="resetForm"
                        class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">å–æ¶ˆ</button>
                </div>
            </div>

            <!-- é…ç½®åˆ—è¡¨ -->
            <div class="grid gap-3">
                <div v-for="conf in llmConfigs" :key="conf.id"
                    class="flex items-center justify-between p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow">
                    <div>
                        <div class="font-bold text-slate-800 text-sm">{{ conf.name }}</div>
                        <div class="text-xs text-slate-400 mt-1">{{ conf.model }} | {{ conf.baseUrl }}</div>
                    </div>
                    <div class="flex gap-2">
                        <button @click="editConfig(conf)"
                            class="text-xs text-blue-600 hover:underline font-medium">ç¼–è¾‘</button>
                        <button @click="deleteConfig(conf.id)"
                            class="text-xs text-red-500 hover:underline font-medium">åˆ é™¤</button>
                    </div>
                </div>
                <div v-if="llmConfigs.length === 0" class="text-center py-8 text-slate-400 text-sm">
                    æš‚æ— é…ç½®ï¼Œè¯·åœ¨ä¸Šæ–¹æ·»åŠ 
                </div>
            </div>

            <h2 class="text-lg font-bold text-slate-800 border-b pb-2 pt-6">TTS è¯­éŸ³åˆæˆé…ç½®</h2>
            <!-- æ·»åŠ /ç¼–è¾‘è¡¨å• -->
            <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingTts ? 'ç¼–è¾‘ TTS é…ç½®' : 'æ·»åŠ æ–° TTS é…ç½®' }}</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">é…ç½®åç§°</label>
                        <input v-model="ttsForm.name"
                            class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                            placeholder="ä¾‹å¦‚: IndexTTS 2">
                    </div>
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">Base URL</label>
                        <input v-model="ttsForm.baseUrl"
                            class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                            placeholder="http://127.0.0.1:8300">
                    </div>
                </div>
                <div class="flex gap-2">
                    <button type="button" @click.prevent="saveTtsConfig"
                        class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">ä¿å­˜é…ç½®</button>
                    <button type="button" v-if="isEditingTts" @click="resetTtsForm"
                        class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">å–æ¶ˆ</button>
                </div>
            </div>

            <!-- é…ç½®åˆ—è¡¨ -->
            <div class="grid gap-3">
                <div v-for="conf in ttsConfigs" :key="conf.id"
                    class="flex items-center justify-between p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow">
                    <div>
                        <div class="font-bold text-slate-800 text-sm">{{ conf.name }}</div>
                        <div class="text-xs text-slate-400 mt-1">{{ conf.baseUrl }}</div>
                    </div>
                    <div class="flex gap-2">
                        <button @click="editTtsConfig(conf)"
                            class="text-xs text-blue-600 hover:underline font-medium">ç¼–è¾‘</button>
                        <button @click="deleteTtsConfig(conf.id)"
                            class="text-xs text-red-500 hover:underline font-medium">åˆ é™¤</button>
                    </div>
                </div>
                <div v-if="ttsConfigs.length === 0" class="text-center py-8 text-slate-400 text-sm">
                    æš‚æ—  TTS é…ç½®ï¼Œè¯·åœ¨ä¸Šæ–¹æ·»åŠ 
                </div>
            </div>
        </div>

        <!-- é¡µé¢ 4: éŸ³è‰²èµ„æºåº“ -->
        <div v-if="activeTab === 'timbres'" class="space-y-8">
            <!-- éŸ³è‰²ç®¡ç†åŒºåŸŸ -->
            <section class="space-y-6">
                <h2 class="text-lg font-bold text-slate-800 border-b pb-2">éŸ³è‰²ç®¡ç†</h2>
                <!-- æ·»åŠ /ç¼–è¾‘è¡¨å• -->
                <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                    <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingTimbre ? 'ç¼–è¾‘éŸ³è‰²' : 'æ·»åŠ æ–°éŸ³è‰²' }}</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div class="md:col-span-2">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">ç›®æ ‡ TTS æœåŠ¡
                                (ç”¨äºä¸Šä¼ éŸ³é¢‘)</label>
                            <select v-model="currentTtsConfigId"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white">
                                <option value="" disabled>-- è¯·é€‰æ‹© TTS æ¨¡å‹ --</option>
                                <option v-for="conf in ttsConfigs" :key="conf.id" :value="conf.id">
                                    {{ conf.name }} ({{ conf.baseUrl }})
                                </option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">éŸ³è‰²åç§°</label>
                            <input v-model="timbreForm.name"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                placeholder="ä¾‹å¦‚: æ—ç™½ / å°‘å¹´éŸ³">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">éŸ³è‰²æè¿° (ç”¨äº AI
                                è‡ªåŠ¨åŒ¹é…)</label>
                            <input v-model="timbreForm.description"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                placeholder="ä¾‹å¦‚: å£°éŸ³ä½æ²‰ï¼Œé€‚åˆåæ´¾æˆ–ä¸­å¹´ç”·æ€§">
                        </div>
                        <div class="md:col-span-2">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">å‚è€ƒéŸ³é¢‘æ–‡ä»¶</label>
                            <div class="flex gap-2 items-center">
                                <input type="file" ref="timbreFileRef" @change="handleTimbreFileUpload"
                                    accept=".wav,.mp3" class="hidden">
                                <button type="button" @click="$refs.timbreFileRef.click()"
                                    class="whitespace-nowrap px-3 py-2 bg-slate-100 border border-slate-300 text-slate-600 rounded-lg text-xs hover:bg-slate-200 transition-colors">é€‰æ‹©æ–‡ä»¶</button>
                                <input v-model="timbreForm.refPath"
                                    class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                    placeholder="é€‰æ‹©ä¸€ä¸ªéŸ³é¢‘æ–‡ä»¶ä½œä¸ºéŸ³è‰²å‚è€ƒ">
                            </div>
                            <p class="text-[10px] text-slate-400 mt-1">æç¤ºï¼šé€‰æ‹©çš„éŸ³é¢‘æ–‡ä»¶å°†è¢«ä¸Šä¼ è‡³ TTS æœåŠ¡å™¨ä½œä¸ºéŸ³è‰²å‚è€ƒã€‚è¯·ç¡®ä¿TTSæœåŠ¡å™¨å·²å¯åŠ¨ã€‚</p>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button type="button" @click.prevent="saveTimbre"
                            class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">ä¿å­˜éŸ³è‰²</button>
                        <button type="button" v-if="isEditingTimbre" @click="resetTimbreForm"
                            class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">å–æ¶ˆ</button>
                    </div>
                </div>

                <!-- éŸ³è‰²åˆ—è¡¨ -->
                <div class="grid gap-3">
                    <div v-for="timbre in timbres" :key="timbre.id"
                        class="flex items-center justify-between p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow">
                        <div class="flex items-center gap-3">
                            <div
                                class="w-10 h-10 rounded-full bg-indigo-100 text-indigo-600 flex items-center justify-center font-bold text-lg">
                                {{ timbre.name.charAt(0) }}
                            </div>
                            <div>
                                <div class="font-bold text-slate-800 text-sm">{{ timbre.name }}</div>
                                <div v-if="timbre.description" class="text-xs text-slate-500 mt-0.5">{{
                                    timbre.description }}</div>
                                <div class="text-xs text-slate-400 mt-1">{{ timbre.refPath }}</div>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button @click="playPreview(timbre.refPath)"
                                class="text-xs text-slate-400 hover:text-green-600 mr-1" title="è¯•å¬">
                                <svg v-if="previewPlayingFile === timbre.refPath" class="h-4 w-4 text-green-600"
                                    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z"
                                        clip-rule="evenodd" />
                                </svg>
                                <svg v-else class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"
                                    fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z"
                                        clip-rule="evenodd" />
                                </svg>
                            </button>
                            <button @click="editTimbre(timbre)"
                                class="text-xs text-blue-600 hover:underline font-medium">ç¼–è¾‘</button>
                            <button @click="deleteTimbre(timbre.id)"
                                class="text-xs text-red-500 hover:underline font-medium">åˆ é™¤</button>
                        </div>
                    </div>
                    <div v-if="timbres.length === 0" class="text-center py-8 text-slate-400 text-sm">
                        æš‚æ— éŸ³è‰²ï¼Œè¯·åœ¨ä¸Šæ–¹æ·»åŠ 
                    </div>
                </div>
            </section>

            <!-- æƒ…ç»ªå‘é‡é¢„è®¾åŒºåŸŸ -->
            <section class="space-y-6">
                <h2 class="text-lg font-bold text-slate-800 border-b pb-2">æƒ…ç»ªæè¿°é¢„è®¾</h2>
                <!-- æ·»åŠ /ç¼–è¾‘æƒ…ç»ªè¡¨å• -->
                <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                    <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingEmotion ? 'ç¼–è¾‘æƒ…ç»ªé¢„è®¾' : 'æ·»åŠ æ–°æƒ…ç»ªé¢„è®¾' }}</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">æƒ…ç»ªåç§°</label>
                            <input v-model="emotionForm.name"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                placeholder="ä¾‹å¦‚: å¼€å¿ƒ / æ„¤æ€’">
                        </div>
                        <div class="md:col-span-2">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-2">8ç»´æƒ…æ„Ÿå‘é‡ (å¯¹åº”: é«˜å…´, ç”Ÿæ°”,
                                ä¼¤å¿ƒ, å®³æ€•, åŒæ¶, ä½è½, æƒŠå–œ, å¹³é™) <span
                                    class="text-slate-400 font-normal ml-2 normal-case">æç¤ºï¼šæ‰€æœ‰å€¼å¿…é¡»åœ¨ 0.0 åˆ° 1.0
                                    ä¹‹é—´</span></label>
                            <div class="grid grid-cols-4 md:grid-cols-8 gap-2">
                                <div v-for="(val, idx) in 8" :key="idx" class="flex flex-col items-center">
                                    <span class="text-[8px] text-slate-400 mb-1">{{
                                        ['é«˜å…´','ç”Ÿæ°”','ä¼¤å¿ƒ','å®³æ€•','åŒæ¶','ä½è½','æƒŠå–œ','å¹³é™'][idx] }}</span>
                                    <input type="number" step="0.1" min="0" max="1"
                                        v-model.number="emotionForm.vector[idx]"
                                        class="w-full px-1 py-1 border rounded text-xs text-center focus:ring-1 focus:ring-blue-500"
                                        placeholder="0">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button type="button" @click.prevent="saveEmotion"
                            class="px-4 py-2 bg-green-600 text-white rounded-lg text-xs font-bold hover:bg-green-700 transition-all">ä¿å­˜æƒ…ç»ª</button>
                        <button type="button" v-if="isEditingEmotion" @click="resetEmotionForm"
                            class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">å–æ¶ˆ</button>
                    </div>
                </div>

                <!-- æƒ…ç»ªåˆ—è¡¨ -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                    <div v-for="emo in emotionPresets.filter(e => !isSystemEmotion(e.name))" :key="emo.id"
                        class="p-3 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow flex justify-between items-center">
                        <div class="flex items-center gap-3">
                            <input type="checkbox" v-model="emo.enabled"
                                class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500 cursor-pointer"
                                title="å¯ç”¨/ç¦ç”¨æ­¤æƒ…ç»ª">
                            <div>
                                <div class="font-bold text-slate-800 text-sm">{{ emo.name }}</div>
                                <div class="text-[8px] text-slate-400 mt-1 font-mono tracking-tighter"
                                    v-if="emo.vector">[{{ emo.vector.join(',') }}]</div>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button @click="editEmotion(emo)" class="text-xs text-blue-600 hover:underline">ç¼–è¾‘</button>
                            <button @click="deleteEmotion(emo.id)"
                                class="text-xs text-red-500 hover:underline">åˆ é™¤</button>
                        </div>
                    </div>
                </div>
            </section>
        </div>

        <!-- é¡µé¢ 6: éŸ³æ•ˆç´ æåº“ -->
        <div v-if="activeTab === 'sfx'" class="space-y-8">
            <section class="space-y-6">
                <h2 class="text-lg font-bold text-slate-800 border-b pb-2">éŸ³æ•ˆç´ æç®¡ç†</h2>
                <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                    <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingSfx ? 'ç¼–è¾‘éŸ³æ•ˆ' : 'æ·»åŠ æ–°éŸ³æ•ˆ' }}</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">éŸ³æ•ˆåç§°</label>
                            <input v-model="sfxForm.name"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                placeholder="ä¾‹å¦‚: å¼€é—¨å£° / é›·å£°">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">éŸ³æ•ˆæè¿° (ç”¨äº AI
                                åˆ¤æ–­æ’å…¥)</label>
                            <input v-model="sfxForm.description"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                placeholder="ä¾‹å¦‚: æ²‰é‡çš„æœ¨é—¨è¢«ç”¨åŠ›å…³ä¸Š">
                        </div>
                        <div class="md:col-span-2">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">éŸ³é¢‘æ–‡ä»¶å / è·¯å¾„</label>
                            <div class="flex gap-2 items-center">
                                <input type="file" ref="sfxFileRef" @change="handleSfxFileUpload" accept=".wav,.mp3"
                                    class="hidden">
                                <button type="button" @click="$refs.sfxFileRef.click()"
                                    class="whitespace-nowrap px-3 py-2 bg-slate-100 border border-slate-300 text-slate-600 rounded-lg text-xs hover:bg-slate-200 transition-colors">é€‰æ‹©æ–‡ä»¶</button>
                                <input v-model="sfxForm.filename"
                                    class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                    placeholder="ä¾‹å¦‚: door_slam.wav">
                            </div>
                            <p class="text-[10px] text-slate-400 mt-1"></p>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button type="button" @click.prevent="saveSfx"
                            class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">ä¿å­˜éŸ³æ•ˆ</button>
                        <button type="button" v-if="isEditingSfx" @click="resetSfxForm"
                            class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">å–æ¶ˆ</button>
                    </div>
                </div>

                <div class="grid gap-3">
                    <div v-for="sfx in sfxLibrary" :key="sfx.id"
                        class="flex items-center justify-between p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow">
                        <div class="flex items-center gap-3">
                            <input type="checkbox" v-model="sfx.enabled"
                                class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500 cursor-pointer"
                                title="å¯ç”¨/ç¦ç”¨æ­¤èµ„æº">
                            <div>
                                <div class="font-bold text-slate-800 text-sm">{{ sfx.name }}</div>
                                <div class="text-xs text-slate-500 mt-0.5">{{ sfx.description }}</div>
                                <div class="text-xs text-slate-400 mt-1">{{ sfx.filename }}</div>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button @click="playPreview(sfx.filename)"
                                class="text-xs text-slate-400 hover:text-green-600 mr-1" title="è¯•å¬">
                                <svg v-if="previewPlayingFile === sfx.filename" class="h-4 w-4 text-green-600"
                                    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z"
                                        clip-rule="evenodd" />
                                </svg>
                                <svg v-else class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"
                                    fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z"
                                        clip-rule="evenodd" />
                                </svg>
                            </button>
                            <button @click="editSfx(sfx)"
                                class="text-xs text-blue-600 hover:underline font-medium">ç¼–è¾‘</button>
                            <button @click="deleteSfx(sfx.id)"
                                class="text-xs text-red-500 hover:underline font-medium">åˆ é™¤</button>
                        </div>
                    </div>
                    <div v-if="sfxLibrary.length === 0" class="text-center py-8 text-slate-400 text-sm">æš‚æ— éŸ³æ•ˆç´ æ</div>
                </div>

                <!-- AI éŸ³æ•ˆç”Ÿæˆ (MOSS-SoundEffect) -->
                <div class="bg-gradient-to-r from-indigo-50 to-purple-50 p-5 rounded-xl border border-indigo-200">
                    <h3 class="text-sm font-bold text-indigo-700 mb-4">ğŸ¤– AI éŸ³æ•ˆç”Ÿæˆ (MOSS-SoundEffect)</h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                        <div class="md:col-span-3">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">éŸ³æ•ˆæè¿°</label>
                            <textarea v-model="sfxGenForm.description" rows="2"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-indigo-500 outline-none"
                                placeholder="ä¾‹å¦‚: è¿œå¤„ä¼ æ¥çš„é›·é¸£å£°ä¼´ç€å¤§é›¨è½åœ¨é‡‘å±å±‹é¡¶ä¸Š"></textarea>
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">æ—¶é•¿ (ç§’)</label>
                            <input type="number" v-model="sfxGenForm.duration" min="1" max="30" step="1"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-indigo-500 outline-none"
                                placeholder="5">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">éŸ³æ•ˆåç§° (ä¿å­˜ç”¨)</label>
                            <input v-model="sfxGenForm.name"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-indigo-500 outline-none"
                                placeholder="ä¾‹å¦‚: é›·é›¨å£°">
                        </div>
                        <div class="flex items-end">
                            <button @click="generateSfxWithMoss" :disabled="isGeneratingSfx"
                                class="w-full px-4 py-2 bg-indigo-600 text-white rounded-lg text-xs font-bold hover:bg-indigo-700 transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                                {{ isGeneratingSfx ? 'â³ ç”Ÿæˆä¸­...' : 'ğŸµ AI ç”ŸæˆéŸ³æ•ˆ' }}
                            </button>
                        </div>
                    </div>
                </div>
            </section>

            <section class="space-y-6 border-t border-slate-200 pt-6">
                <h2 class="text-lg font-bold text-slate-800 border-b pb-2">èƒŒæ™¯éŸ³ä¹ç®¡ç† (BGM)</h2>
                <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                    <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingBgm ? 'ç¼–è¾‘ BGM' : 'æ·»åŠ æ–° BGM' }}</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">BGM åç§°</label>
                            <input v-model="bgmForm.name"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                placeholder="ä¾‹å¦‚: æ‚²ä¼¤é’¢ç´ / æˆ˜æ–—æ¿€æ˜‚">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">BGM æè¿° (ç”¨äº AI
                                åˆ¤æ–­)</label>
                            <input v-model="bgmForm.description"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                placeholder="ä¾‹å¦‚: é€‚åˆæ‚²ä¼¤åœºæ™¯çš„é’¢ç´æ›²">
                        </div>
                        <div class="md:col-span-2">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">éŸ³é¢‘æ–‡ä»¶å / è·¯å¾„</label>
                            <div class="flex gap-2 items-center">
                                <input type="file" ref="bgmFileRef" @change="handleBgmFileUpload" accept=".wav,.mp3"
                                    class="hidden">
                                <button type="button" @click="$refs.bgmFileRef.click()"
                                    class="whitespace-nowrap px-3 py-2 bg-slate-100 border border-slate-300 text-slate-600 rounded-lg text-xs hover:bg-slate-200 transition-colors">é€‰æ‹©æ–‡ä»¶</button>
                                <input v-model="bgmForm.filename"
                                    class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                    placeholder="ä¾‹å¦‚: sad_piano.mp3">
                            </div>
                            <p class="text-[10px] text-slate-400 mt-1"></p>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button type="button" @click.prevent="saveBgm"
                            class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">ä¿å­˜
                            BGM</button>
                        <button type="button" v-if="isEditingBgm" @click="resetBgmForm"
                            class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">å–æ¶ˆ</button>
                    </div>
                </div>

                <div class="grid gap-3">
                    <div v-for="bgm in bgmLibrary" :key="bgm.id"
                        class="flex items-center justify-between p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow">
                        <div class="flex items-center gap-3">
                            <input type="checkbox" v-model="bgm.enabled"
                                class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500 cursor-pointer"
                                title="å¯ç”¨/ç¦ç”¨æ­¤èµ„æº">
                            <div>
                                <div class="font-bold text-slate-800 text-sm">{{ bgm.name }}</div>
                                <div class="text-xs text-slate-500 mt-0.5">{{ bgm.description }}</div>
                                <div class="text-xs text-slate-400 mt-1">{{ bgm.filename }}</div>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button @click="playPreview(bgm.filename)"
                                class="text-xs text-slate-400 hover:text-green-600 mr-1" title="è¯•å¬">
                                <svg v-if="previewPlayingFile === bgm.filename" class="h-4 w-4 text-green-600"
                                    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z"
                                        clip-rule="evenodd" />
                                </svg>
                                <svg v-else class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"
                                    fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z"
                                        clip-rule="evenodd" />
                                </svg>
                            </button>
                            <button @click="editBgm(bgm)"
                                class="text-xs text-blue-600 hover:underline font-medium">ç¼–è¾‘</button>
                            <button @click="deleteBgm(bgm.id)"
                                class="text-xs text-red-500 hover:underline font-medium">åˆ é™¤</button>
                        </div>
                    </div>
                    <div v-if="bgmLibrary.length === 0" class="text-center py-8 text-slate-400 text-sm">æš‚æ—  BGM ç´ æ</div>
                </div>
            </section>

            <section class="space-y-6 border-t border-slate-200 pt-6">
                <h2 class="text-lg font-bold text-slate-800 border-b pb-2">éŸ³é¢‘æ»¤æ³¢å™¨ç®¡ç†</h2>
                <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                    <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingFilter ? 'ç¼–è¾‘æ»¤æ³¢å™¨' : 'æ·»åŠ æ–°æ»¤æ³¢å™¨' }}</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">æ»¤æ³¢å™¨åç§°</label>
                            <input v-model="filterForm.name"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                placeholder="ä¾‹å¦‚: ç”µè¯éŸ³ / æ°´ä¸‹">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">æ»¤æ³¢å™¨æè¿° (ç”¨äº AI
                                åˆ¤æ–­)</label>
                            <input v-model="filterForm.description"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                placeholder="ä¾‹å¦‚: å£°éŸ³é€šè¿‡ç”µè¯ä¼ è¾“ï¼Œé¢‘æ®µå˜çª„">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">æ»¤æ³¢å™¨ç±»å‹</label>
                            <select v-model="filterForm.type"
                                class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white">
                                <option value="lowpass">ä½é€š (Lowpass) - é€‚åˆæ°´ä¸‹/é—·å£°</option>
                                <option value="highpass">é«˜é€š (Highpass) - é€‚åˆæ”¶éŸ³æœº/å°–é”</option>
                                <option value="bandpass">å¸¦é€š (Bandpass) - é€‚åˆç”µè¯/å¯¹è®²æœº</option>
                                <option value="distortion">å¤±çœŸ (Distortion) - é€‚åˆæœºå™¨äºº/æŸåè®¾å¤‡</option>
                            </select>
                        </div>
                        <div v-if="filterForm.type !== 'distortion'">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">é¢‘ç‡ (Hz): {{
                                filterForm.frequency }}</label>
                            <input type="range" v-model.number="filterForm.frequency" min="20" max="20000" step="10"
                                class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        </div>
                        <div v-if="filterForm.type !== 'distortion'">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">Q å€¼ (å…±æŒ¯å³°): {{
                                filterForm.Q }}</label>
                            <input type="range" v-model.number="filterForm.Q" min="0.1" max="20" step="0.1"
                                class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        </div>
                        <div v-if="filterForm.type === 'distortion'">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">å¤±çœŸåº¦ (Amount): {{
                                filterForm.gain }}</label>
                            <input type="range" v-model.number="filterForm.gain" min="0" max="1000" step="10"
                                class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-red-600">
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button type="button" @click.prevent="saveFilter"
                            class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">ä¿å­˜æ»¤æ³¢å™¨</button>
                        <button type="button" v-if="isEditingFilter" @click="resetFilterForm"
                            class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">å–æ¶ˆ</button>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                    <div v-for="filter in filterLibrary" :key="filter.id"
                        class="p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow flex justify-between items-center">
                        <div class="flex items-center gap-3">
                            <input type="checkbox" v-model="filter.enabled"
                                class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500 cursor-pointer"
                                title="å¯ç”¨/ç¦ç”¨æ­¤èµ„æº">
                            <div>
                                <div class="font-bold text-slate-800 text-sm">{{ filter.name }}</div>
                                <div class="text-xs text-slate-500 mt-0.5">{{ filter.description }}</div>
                                <div class="text-[10px] text-slate-400 mt-1 font-mono">{{ filter.type }} | {{
                                    filter.type === 'distortion' ? `Amt:${filter.gain}` : `Freq:${filter.frequency}Hz`
                                    }}</div>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button @click="editFilter(filter)"
                                class="text-xs text-blue-600 hover:underline font-medium">ç¼–è¾‘</button>
                            <button @click="deleteFilter(filter.id)"
                                class="text-xs text-red-500 hover:underline font-medium">åˆ é™¤</button>
                        </div>
                    </div>
                    <div v-if="filterLibrary.length === 0"
                        class="col-span-full text-center py-8 text-slate-400 text-sm">æš‚æ— æ»¤æ³¢å™¨ï¼Œè¯·æ·»åŠ </div>
                </div>
            </section>
        </div>

        <!-- é¡µé¢ 5: è„šæœ¬åˆ¶ä½œ (é‡æ„ï¼šå·¦å³åˆ†æ ) -->
        <div v-if="activeTab === 'script'" class="flex flex-col lg:flex-row gap-6 items-start">

            <!-- å·¦ä¾§ï¼šè§’è‰²ä¸éŸ³è‰²ç»‘å®šæ  -->
            <div class="w-full lg:w-60 flex-shrink-0 space-y-4">
                <div class="bg-slate-100 p-4 rounded-xl border border-slate-200">
                    <h3 class="text-sm font-bold text-slate-700 mb-3 flex justify-between items-center">
                        è§’è‰²åˆ—è¡¨
                        <button @click="addCharacter"
                            class="text-xs bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700">+ æ–°å¢</button>
                    </h3>
                    <div class="space-y-3 pr-1">
                        <div v-for="char in characters" :key="char.id"
                            class="bg-white p-3 rounded-lg border border-slate-200 shadow-sm text-sm space-y-2">
                            <div class="flex justify-between items-center">
                                <input v-model="char.name"
                                    class="font-bold text-slate-800 w-2/3 bg-transparent border-b border-transparent focus:border-blue-500 outline-none px-1"
                                    placeholder="è§’è‰²å">
                                <button @click="deleteCharacter(char.id)"
                                    class="text-slate-400 hover:text-red-500">Ã—</button>
                            </div>

                            <div>
                                <div class="flex justify-between items-center mb-1">
                                    <label class="block text-[10px] font-bold text-slate-500 uppercase">éŸ³è‰²é€‰æ‹©</label>
                                    <button @click="openVoiceRecordModal(char)"
                                        class="text-[10px] text-blue-500 hover:text-blue-700 font-bold flex items-center gap-1">ğŸ¤
                                        å½•åˆ¶/ä¸Šä¼ å‚è€ƒéŸ³é¢‘</button>
                                </div>
                                <div class="flex gap-1">
                                    <select v-model="char.voiceFile"
                                        class="flex-1 px-2 py-1.5 border rounded-md text-xs bg-white outline-none focus:ring-1 focus:ring-blue-500">
                                        <option value="">-- è¯·é€‰æ‹©éŸ³è‰² --</option>
                                        <option v-for="timbre in timbres" :key="timbre.id" :value="timbre.refPath">
                                            {{ timbre.name }}
                                        </option>
                                    </select>
                                    <button @click="playPreview(char.voiceFile)" :disabled="!char.voiceFile"
                                        class="px-2 bg-slate-100 border border-slate-200 rounded text-slate-500 hover:text-green-600 disabled:opacity-50"
                                        title="è¯•å¬å½“å‰éŸ³è‰²">
                                        <svg v-if="previewPlayingFile === char.voiceFile" class="h-4 w-4 text-green-600"
                                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd"
                                                d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z"
                                                clip-rule="evenodd" />
                                        </svg>
                                        <svg v-else class="h-4 w-4" xmlns="http://www.w3.org/2000/svg"
                                            viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd"
                                                d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z"
                                                clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                </div>
                            </div>

                            <div class="mt-2 pt-2 border-t border-slate-100 space-y-2">
                                <textarea v-model="char.voiceDescription" rows="2"
                                    class="w-full px-2 py-1.5 text-[10px] border rounded bg-slate-50 focus:ring-1 focus:ring-blue-500 outline-none resize-none text-slate-600"
                                    placeholder="éŸ³è‰²æè¿° (ä¾‹å¦‚: ç”œç¾å°‘å¥³éŸ³)"></textarea>
                                <div class="flex gap-1">
                                    <button @click="analyzeCharacterVoice(char)"
                                        :class="['flex-1 px-2 py-1.5 border rounded text-[10px] font-bold transition-colors flex justify-center items-center gap-1', char.isAnalyzing ? 'bg-red-50 text-red-600 border-red-100 hover:bg-red-100' : 'bg-indigo-50 text-indigo-600 border-indigo-100 hover:bg-indigo-100']">
                                        <span v-if="char.isAnalyzing" class="animate-spin">â³</span>{{ char.isAnalyzing ?
                                        'åœæ­¢åˆ†æ' : 'AIåˆ†æéŸ³è‰²' }}
                                    </button>
                                    <button @click="generateQwenVoice(char)"
                                        :class="['flex-1 px-2 py-1.5 border rounded text-[10px] font-bold transition-colors flex justify-center items-center gap-1', char.isGeneratingVoice ? 'bg-red-50 text-red-600 border-red-100 hover:bg-red-100' : 'bg-pink-50 text-pink-600 border-pink-100 hover:bg-pink-100']">
                                        <span v-if="char.isGeneratingVoice" class="animate-spin">â³</span>{{
                                        char.isGeneratingVoice ? 'åœæ­¢' : 'Qwen3éŸ³è‰²' }}
                                    </button>
                                    <button @click="generateMossVoice(char)"
                                        :class="['flex-1 px-2 py-1.5 border rounded text-[10px] font-bold transition-colors flex justify-center items-center gap-1', char.isGeneratingMossVoice ? 'bg-red-50 text-red-600 border-red-100 hover:bg-red-100' : 'bg-emerald-50 text-emerald-600 border-emerald-100 hover:bg-emerald-100']">
                                        <span v-if="char.isGeneratingMossVoice" class="animate-spin">â³</span>{{
                                        char.isGeneratingMossVoice ? 'åœæ­¢' : 'MOSSéŸ³è‰²' }}
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div v-if="characters.length === 0" class="text-center text-xs text-slate-400 py-4">æš‚æ— è§’è‰²ï¼Œè¯·ç‚¹å‡»æ–°å¢
                        </div>
                    </div>
                </div>
            </div>

            <!-- åŸæ–‡è¾“å…¥åŒºåŸŸ -->
            <div class="flex-1 w-full space-y-6 min-w-0">
                <div class="bg-white p-5 rounded-xl border border-slate-200 shadow-sm">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-sm font-bold text-slate-700">1. è¾“å…¥åŸæ–‡ / å°è¯´ç‰‡æ®µ</h3>
                    </div>

                    <div class="mb-4 bg-slate-50 p-3 rounded-lg border border-slate-100">
                        <div class="flex flex-wrap items-center gap-2">
                            <button @click="exportScriptState" :disabled="isExportingProject"
                                class="px-3 py-1.5 bg-amber-100 text-amber-700 rounded-lg text-xs font-bold hover:bg-amber-200 transition-all flex items-center gap-1 disabled:opacity-50 disabled:cursor-wait">
                                {{ isExportingProject ? exportStatus : 'å¯¼å‡ºå®Œæ•´å·¥ç¨‹' }}
                            </button>
                            <button @click="triggerImport" :disabled="isExportingProject"
                                class="px-3 py-1.5 bg-amber-100 text-amber-700 rounded-lg text-xs font-bold hover:bg-amber-200 transition-all flex items-center gap-1 disabled:opacity-50">
                                {{ isExportingProject ? 'è¯·ç­‰å¾…...' : 'å¯¼å…¥å®Œæ•´å·¥ç¨‹' }}
                            </button>
                            <button @click="triggerImportTxt" :disabled="isExportingProject"
                                class="px-3 py-1.5 bg-slate-100 text-slate-700 rounded-lg text-xs font-bold hover:bg-slate-200 transition-all flex items-center gap-1 disabled:opacity-50">
                                å¯¼å…¥TXT
                            </button>
                            <button @click="exportSRT" :disabled="isExportingAudio"
                                class="px-3 py-1.5 bg-teal-100 text-teal-700 rounded-lg text-xs font-bold hover:bg-teal-200 transition-all flex items-center gap-1 disabled:opacity-50 disabled:cursor-wait">
                                å¯¼å‡ºSRT
                            </button>
                            <button @click="exportAudio" :disabled="isExportingAudio"
                                class="px-3 py-1.5 bg-purple-100 text-purple-700 rounded-lg text-xs font-bold hover:bg-purple-200 transition-all flex items-center gap-1 disabled:opacity-50 disabled:cursor-wait">
                                {{ isExportingAudio ? 'â³ å¤„ç†ä¸­...' : 'å¯¼å‡ºéŸ³é¢‘' }}
                            </button>
                            <input type="file" ref="importFileRef" @change="handleImportFile" accept=".json"
                                class="hidden">
                            <input type="file" ref="importTxtRef" @change="handleImportTxt" accept=".txt"
                                class="hidden">
                        </div>
                    </div>

                    <textarea v-model="rawScript"
                        class="w-full p-4 border rounded-xl h-48 mb-4 focus:ring-2 focus:ring-blue-500 outline-none resize-none bg-slate-50 text-sm leading-relaxed"
                        placeholder="è¯·ç²˜è´´å°è¯´å†…å®¹æˆ–å‰§æœ¬åŸæ–‡..."></textarea>
                    <div class="flex flex-wrap gap-2">
                        <select v-model="currentConfigId"
                            class="px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white max-w-[180px]"
                            title="é€‰æ‹©ç”¨äºåˆ†æçš„ LLM æ¨¡å‹">
                            <option value="" disabled>-- é€‰æ‹©LLMæ¨¡å‹ --</option>
                            <option v-for="conf in llmConfigs" :key="conf.id" :value="conf.id">
                                {{ conf.name }}
                            </option>
                        </select>
                        <button @click="analyzeScript"
                            :class="['px-3 py-2 text-white rounded-lg text-sm font-bold transition-all flex items-center', isAnalyzingScript ? 'bg-red-500 hover:bg-red-600' : 'bg-indigo-600 hover:bg-indigo-700 disabled:opacity-50']">
                            <span v-if="isAnalyzingScript" class="animate-spin mr-2">â³</span> {{ isAnalyzingScript ?
                            'åœæ­¢åˆ†æ' : 'AI æ·±åº¦åˆ†æ' }}
                        </button>
                        <button @click="addDialogueBlock"
                            class="px-2 py-2 bg-blue-100 text-blue-600 rounded-lg text-sm font-bold hover:bg-blue-200 transition-all">
                            â• æ’å…¥å°è¯
                        </button>
                        <button @click="addBgmBlock"
                            class="px-2 py-2 bg-purple-100 text-purple-600 rounded-lg text-sm font-bold hover:bg-purple-200 transition-all">
                            â• æ’å…¥BGM
                        </button>
                        <select v-model="currentTtsConfigId"
                            class="px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white max-w-[180px]"
                            title="é€‰æ‹©ç”¨äºç”Ÿæˆçš„ TTS æœåŠ¡">
                            <option value="" disabled>-- é€‰æ‹© TTS æ¨¡å‹ --</option>
                            <option v-for="conf in ttsConfigs" :key="conf.id" :value="conf.id">
                                {{ conf.name }}
                            </option>
                        </select>
                        <button @click="generateAllLines" :disabled="isSequencePlaying"
                            :class="['px-2 py-2 text-white rounded-lg text-sm font-bold transition-all flex items-center', isGeneratingAll ? 'bg-red-500 hover:bg-red-600' : 'bg-green-600 hover:bg-green-700 disabled:opacity-50']">
                            <span v-if="isGeneratingAll" class="animate-spin mr-2">â³</span> {{ isGeneratingAll ? 'åœæ­¢ç”Ÿæˆ'
                            : (selectedLineIndex !== -1 ? 'ä»é€‰ä¸­è¡Œå¼€å§‹ç”Ÿæˆ' : 'ä¸€é”®ç”Ÿæˆé…éŸ³(è·³è¿‡å·²ç”Ÿæˆ)') }}
                        </button>
                        <button @click="clearAllGeneratedAudio" :disabled="isSequencePlaying || isGeneratingAll"
                            class="px-2 py-2 bg-red-600 text-white rounded-lg text-sm font-bold hover:bg-red-700 disabled:opacity-50 transition-all flex items-center">
                            æ¸…ç©ºé…éŸ³
                        </button>
                        <button v-if="!isSequencePlaying" @click="playScriptSequentially"
                            class="px-2 py-2 bg-blue-600 text-white rounded-lg text-sm font-bold hover:bg-blue-700 disabled:opacity-50 transition-all">
                            {{ selectedLineIndex !== -1 ? 'â–¶ï¸ ä»é€‰ä¸­ä½ç½®æ’­æ”¾' : 'â–¶ï¸ é¡ºåºæ’­æ”¾' }}
                        </button>
                        <button v-else @click="stopScriptSequentially"
                            class="px-6 py-2 bg-red-500 text-white rounded-lg text-sm font-bold hover:bg-red-600 transition-all">
                            åœæ­¢æ’­æ”¾
                        </button>
                        <div class="flex-grow"></div>
                    </div>
                </div>

                <!-- æ‹†åˆ†ç»“æœåˆ—è¡¨ -->
                <div v-if="scriptLines.length > 0" class="bg-white p-5 rounded-xl border border-slate-200 shadow-sm">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-sm font-bold text-slate-700">2. è„šæœ¬å°è¯åˆ—è¡¨ ({{ scriptLines.length }} è¡Œ)</h3>
                    </div>
                    <div ref="scriptListContainer" class="space-y-3 max-h-[600px] overflow-y-auto px-2 pb-10">
                        <div v-for="(line, index) in scriptLines" :key="line.id"
                            @click="toggleLineSelection(index, $event)" :ref="el => { if (el) lineRefs[index] = el }"
                            class="transition-all duration-200">

                            <!-- BGM æ§åˆ¶å— -->
                            <div v-if="line.type === 'bgm'"
                                :class="['flex items-center gap-3 p-3 rounded-lg border mb-2 transition-all', selectedLineIndex === index ? 'border-purple-500 bg-purple-50 shadow-md' : 'bg-purple-50/50 border-purple-200', currentSequenceIndex === index ? 'ring-2 ring-green-500' : '']">
                                <div
                                    class="flex flex-col items-center justify-center gap-1 w-8 flex-shrink-0 border-r border-purple-200 pr-2">
                                    <button @click.stop="moveLineUp(index)"
                                        class="text-purple-400 hover:text-purple-700 p-0.5 hover:bg-purple-100 rounded"
                                        title="ä¸Šç§»">â–²</button>
                                    <div class="text-xs font-bold text-purple-500 select-none">{{ index + 1 }}</div>
                                    <button @click.stop="moveLineDown(index)"
                                        class="text-purple-400 hover:text-purple-700 p-0.5 hover:bg-purple-100 rounded"
                                        title="ä¸‹ç§»">â–¼</button>
                                </div>
                                <div
                                    class="w-24 flex-shrink-0 font-bold text-xs text-purple-600 uppercase tracking-wider flex items-center justify-center border-r border-purple-200 pr-3">
                                    BGM æ§åˆ¶
                                </div>
                                <select v-model="line.action"
                                    class="w-24 px-2 py-1.5 text-xs border rounded bg-white focus:ring-1 focus:ring-purple-500 outline-none font-bold text-purple-700">
                                    <option value="play">â–¶ æ’­æ”¾</option>
                                    <option value="stop">åœæ­¢</option>
                                </select>
                                <div class="flex-1 flex items-center gap-2">
                                    <select v-if="line.action === 'play'" v-model="line.bgmName"
                                        class="flex-1 px-2 py-1.5 text-xs border rounded bg-white focus:ring-1 focus:ring-purple-500 outline-none font-bold text-purple-700">
                                        <option value="" disabled>-- é€‰æ‹©èƒŒæ™¯éŸ³ä¹ --</option>
                                        <option v-for="s in bgmLibrary" :key="s.id" :value="s.name">{{ s.name }}
                                        </option>
                                    </select>
                                    <div v-else class="flex-1 text-xs text-slate-400 italic py-1.5 px-2">åœæ­¢å½“å‰æ’­æ”¾çš„æ‰€æœ‰èƒŒæ™¯éŸ³ä¹
                                    </div>
                                    <div v-if="line.action === 'play'" class="w-24 flex-shrink-0 space-y-1">
                                        <div
                                            class="text-[10px] font-bold text-slate-400 uppercase text-center leading-tight">
                                            BGMéŸ³é‡</div>
                                        <input type="range" v-model="line.volume" min="0" max="1" step="0.05"
                                            class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-purple-600">
                                    </div>
                                </div>
                                <button @click="removeScriptLine(index)"
                                    class="text-slate-300 hover:text-red-500 p-2"><svg class="h-4 w-4"
                                        xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd"
                                            d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                                            clip-rule="evenodd" />
                                    </svg></button>
                            </div>

                            <!-- å°è¯å— -->
                            <div v-else
                                :class="['flex flex-col gap-2 p-3 rounded-lg mb-2 transition-all group cursor-pointer border', selectedLineIndex === index ? 'bg-blue-50 border-blue-300 shadow-md' : 'bg-white border-slate-200 shadow-sm hover:bg-slate-50', currentSequenceIndex === index ? 'ring-2 ring-green-500' : '']">
                                <div class="flex flex-wrap items-stretch gap-3">
                                    <div
                                        class="flex flex-col items-center justify-center gap-1 w-8 flex-shrink-0 border-r border-slate-100 pr-2">
                                        <button @click.stop="moveLineUp(index)"
                                            class="text-slate-400 hover:text-blue-600 p-0.5 hover:bg-slate-100 rounded"
                                            title="ä¸Šç§»">â–²</button>
                                        <div class="text-xs font-bold text-slate-400 select-none">{{ index + 1 }}</div>
                                        <button @click.stop="moveLineDown(index)"
                                            class="text-slate-400 hover:text-blue-600 p-0.5 hover:bg-slate-100 rounded"
                                            title="ä¸‹ç§»">â–¼</button>
                                    </div>

                                    <!-- è§’è‰²é€‰æ‹© -->
                                    <div class="w-24 flex-shrink-0 flex flex-col justify-center gap-1">
                                        <select v-model="line.role"
                                            class="w-full px-2 py-1.5 text-xs border rounded bg-white focus:ring-1 focus:ring-blue-500 outline-none font-bold text-slate-700">
                                            <option v-for="roleName in availableRoles" :key="roleName"
                                                :value="roleName">{{ roleName }}</option>
                                        </select>
                                        <!-- æ»¤æ³¢å™¨é€‰æ‹© -->
                                        <select v-model="line.filter"
                                            class="w-full px-2 py-1 text-[10px] border rounded bg-slate-50 focus:ring-1 focus:ring-blue-500 outline-none text-slate-500"
                                            title="éŸ³é¢‘æ»¤æ³¢å™¨">
                                            <option value="">æ— æ»¤æ³¢å™¨</option>
                                            <option v-for="f in filterLibrary" :key="f.id" :value="f.name">{{ f.name }}
                                            </option>
                                        </select>
                                    </div>

                                    <!-- æƒ…ç»ªæè¿° -->
                                    <div class="w-36 flex-shrink-0 space-y-1 flex flex-col justify-center">
                                        <select v-model="line.emotion"
                                            class="w-full px-2 py-1.5 text-xs border rounded bg-white focus:ring-1 focus:ring-blue-500 outline-none text-slate-700 font-bold">
                                            <option value="" disabled>é€‰æ‹©æƒ…ç»ª</option>
                                            <option v-for="preset in emotionPresets" :key="preset.id"
                                                :value="preset.name">{{ preset.name }}</option>
                                        </select>
                                        <select v-model="line.intensity" v-if="isSystemEmotion(line.emotion)"
                                            class="w-full px-2 py-1 text-xs border rounded bg-slate-50 focus:ring-1 focus:ring-blue-500 outline-none text-slate-600">
                                            <option value="å¾®å¼±">å¾®å¼± (0.2)</option>
                                            <option value="ç¨å¼±">ç¨å¼± (0.35)</option>
                                            <option value="ä¸­ç­‰">ä¸­ç­‰ (0.5)</option>
                                            <option value="è¾ƒå¼º">è¾ƒå¼º (0.75)</option>
                                            <option value="å¼ºçƒˆ">å¼ºçƒˆ (1.0)</option>
                                        </select>
                                    </div>

                                    <!-- åœé¡¿é—´éš” -->
                                    <div class="w-16 flex-shrink-0 space-y-1 flex flex-col justify-center">
                                        <div
                                            class="text-[10px] font-bold text-slate-400 uppercase text-center leading-tight">
                                            åœé¡¿(s)</div>
                                        <input type="number" v-model="line.break_duration" step="0.1" min="0"
                                            class="w-full px-1 py-1.5 text-xs border rounded bg-white focus:ring-1 focus:ring-blue-500 outline-none text-center font-mono text-slate-600"
                                            placeholder="0">
                                    </div>

                                    <div class="flex-grow"></div>

                                    <!-- å³ä¾§æ§åˆ¶åŒº -->
                                    <div class="flex flex-col items-end gap-2">
                                        <div class="flex items-center gap-3">
                                            <!-- éŸ³é‡æ§åˆ¶ (åŠ å®½) -->
                                            <div v-if="line.audioUrl"
                                                class="w-48 flex-shrink-0 flex flex-col justify-center gap-2 px-2 border-r border-slate-200">
                                                <div class="w-full">
                                                    <div class="flex justify-between items-center mb-0.5">
                                                        <span
                                                            class="text-[8px] font-bold text-slate-400 uppercase">å°è¯éŸ³é‡</span>
                                                        <span class="text-[8px] text-slate-400 font-mono">{{
                                                            Math.round((line.dialogueVolume || 1) * 100) }}%</span>
                                                    </div>
                                                    <input type="range" v-model="line.dialogueVolume" min="0" max="1"
                                                        step="0.05"
                                                        class="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600 block">
                                                </div>
                                                <div class="w-full">
                                                    <div class="flex justify-between items-center mb-0.5">
                                                        <span
                                                            class="text-[8px] font-bold text-slate-400 uppercase">éŸ³æ•ˆéŸ³é‡</span>
                                                        <span class="text-[8px] text-slate-400 font-mono">{{
                                                            Math.round((line.sfxVolume || 0.5) * 100) }}%</span>
                                                    </div>
                                                    <input type="range" v-model="line.sfxVolume" min="0" max="1"
                                                        step="0.05"
                                                        class="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600 block">
                                                </div>
                                                <div class="w-full">
                                                    <div class="flex justify-between items-center mb-0.5">
                                                        <span
                                                            class="text-[8px] font-bold text-slate-400 uppercase">è¯­é€Ÿ</span>
                                                        <span class="text-[8px] text-slate-400 font-mono">{{ (line.speed
                                                            || 1).toFixed(1) }}x</span>
                                                    </div>
                                                    <input type="range" v-model.number="line.speed" min="0.5" max="2"
                                                        step="0.1"
                                                        class="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-green-600 block">
                                                </div>
                                            </div>

                                            <!-- éŸ³é¢‘æ³¢å½¢å‰ªè¾‘æ¡ -->
                                            <div v-if="line.audioUrl" class="w-48 flex-shrink-0 flex flex-col gap-1">
                                                <div class="flex justify-between items-center px-0.5">
                                                    <span
                                                        class="text-[8px] font-bold text-slate-400 uppercase">éŸ³é¢‘å‰ªè¾‘</span>
                                                    <span class="text-[8px] text-slate-400 font-mono">{{
                                                        Math.round(((line.trimEnd||1) - (line.trimStart||0)) * 100)
                                                        }}%</span>
                                                </div>
                                                <div :key="line.audioUrl"
                                                    class="relative w-full bg-slate-100 rounded border border-slate-200 overflow-hidden select-none group/wave"
                                                    style="height: 32px;">
                                                    <canvas :ref="(el) => drawWaveform(el, line)" width="192"
                                                        height="32" class="w-full h-full block opacity-60"></canvas>

                                                    <!-- é®ç½©å±‚ä¸æ‰‹æŸ„ -->
                                                    <div class="absolute inset-0 pointer-events-none">
                                                        <!-- é˜´å½±é®ç½© (è¢«å‰ªæ‰çš„éƒ¨åˆ†) -->
                                                        <div class="absolute top-0 bottom-0 left-0 bg-slate-500/30 border-r border-blue-500"
                                                            :style="{ width: (line.trimStart || 0) * 100 + '%' }"></div>
                                                        <div class="absolute top-0 bottom-0 right-0 bg-slate-500/30 border-l border-red-500"
                                                            :style="{ width: (1 - (line.trimEnd || 1)) * 100 + '%' }">
                                                        </div>

                                                        <!-- äº¤äº’æ‰‹æŸ„ (æ‰©å¤§ç‚¹å‡»åŒºåŸŸ) -->
                                                        <div class="absolute top-0 bottom-0 w-4 -ml-2 cursor-ew-resize pointer-events-auto hover:bg-blue-500/10 transition-colors flex justify-center group/handle"
                                                            :style="{ left: (line.trimStart || 0) * 100 + '%' }"
                                                            @mousedown.stop="startDragTrim($event, line, 'start')">
                                                            <div
                                                                class="w-0.5 h-full bg-blue-500 group-hover/handle:w-1 transition-all">
                                                            </div>
                                                        </div>
                                                        <div class="absolute top-0 bottom-0 w-4 -ml-2 cursor-ew-resize pointer-events-auto hover:bg-red-500/10 transition-colors flex justify-center group/handle"
                                                            :style="{ left: (line.trimEnd || 1) * 100 + '%' }"
                                                            @mousedown.stop="startDragTrim($event, line, 'end')">
                                                            <div
                                                                class="w-0.5 h-full bg-red-500 group-hover/handle:w-1 transition-all">
                                                            </div>
                                                        </div>

                                                        <!-- æ’­æ”¾è¿›åº¦æ¡ -->
                                                        <div v-if="isAuditioningId === line.id"
                                                            class="absolute top-0 bottom-0 w-0.5 bg-green-500 z-20 pointer-events-none shadow-[0_0_4px_rgba(34,197,94,0.8)]"
                                                            :style="{ left: (playbackProgress * 100) + '%' }"></div>
                                                    </div>
                                                </div>
                                            </div>

                                            <!-- æŒ‰é’®ç»„ -->
                                            <div class="flex items-center gap-1">
                                                <button @click.stop="generateLineAudio(line)"
                                                    :title="line.isGenerating ? 'åœæ­¢ç”Ÿæˆ' : 'ç”ŸæˆéŸ³é¢‘'"
                                                    :class="['p-2', line.isGenerating ? 'text-red-500 hover:text-red-700' : 'text-slate-400 hover:text-indigo-600 disabled:text-slate-300 disabled:cursor-wait']">
                                                    <svg v-if="line.isGenerating" class="animate-spin h-4 w-4"
                                                        xmlns="http://www.w3.org/2000/svg" fill="none"
                                                        viewBox="0 0 24 24">
                                                        <circle class="opacity-25" cx="12" cy="12" r="10"
                                                            stroke="currentColor" stroke-width="4"></circle>
                                                        <path class="opacity-75" fill="currentColor"
                                                            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                                        </path>
                                                    </svg>
                                                    <svg v-else class="h-4 w-4" xmlns="http://www.w3.org/2000/svg"
                                                        viewBox="0 0 20 20" fill="currentColor">
                                                        <path fill-rule="evenodd"
                                                            d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z"
                                                            clip-rule="evenodd" />
                                                    </svg>
                                                </button>
                                                <button v-if="line.audioUrl" @click.stop="playLineAudio(line)"
                                                    title="æ’­æ”¾" class="text-slate-400 hover:text-green-600 p-2">
                                                    <svg v-if="isAuditioningId === line.id"
                                                        class="h-4 w-4 animate-pulse text-green-600"
                                                        xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"
                                                        fill="currentColor">
                                                        <path fill-rule="evenodd"
                                                            d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z"
                                                            clip-rule="evenodd" />
                                                    </svg>
                                                    <svg v-else class="h-4 w-4" xmlns="http://www.w3.org/2000/svg"
                                                        viewBox="0 0 20 20" fill="currentColor">
                                                        <path fill-rule="evenodd"
                                                            d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z"
                                                            clip-rule="evenodd" />
                                                    </svg>
                                                </button>
                                                <button v-if="line.audioUrl" @click.stop="clearLineAudio(line)"
                                                    title="æ¸…é™¤éŸ³é¢‘" class="text-slate-400 hover:text-red-600 p-2">
                                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4"
                                                        viewBox="0 0 20 20" fill="currentColor">
                                                        <path fill-rule="evenodd"
                                                            d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z"
                                                            clip-rule="evenodd" />
                                                    </svg>
                                                </button>
                                                <button @click="removeScriptLine(index)" title="åˆ é™¤"
                                                    class="text-slate-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity p-2">
                                                    <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg"
                                                        viewBox="0 0 20 20" fill="currentColor">
                                                        <path fill-rule="evenodd"
                                                            d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                                                            clip-rule="evenodd" />
                                                    </svg>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- éŸ³æ•ˆç®¡ç†æ¡ -->
                                <div class="flex flex-wrap items-center gap-2 w-full">
                                    <div v-for="(sfx, sIdx) in line.sfx" :key="sIdx"
                                        :class="['flex flex-wrap items-center border rounded px-2 py-1.5 text-xs gap-1', sfxLibrary.some(s => s.name === sfx.name) ? 'bg-blue-50 border-blue-100' : 'bg-orange-50 border-orange-200']">
                                        <span class="mr-0.5"
                                            :class="sfxLibrary.some(s => s.name === sfx.name) ? '' : 'animate-pulse text-xl'">ğŸ”Š</span>
                                        <template v-if="sfxLibrary.some(s => s.name === sfx.name)">
                                            <select v-model="sfx.name"
                                                class="bg-transparent outline-none border-b border-transparent hover:border-blue-300 text-blue-700 font-medium max-w-[100px] cursor-pointer">
                                                <option v-for="libSfx in sfxLibrary" :key="libSfx.id"
                                                    :value="libSfx.name">
                                                    {{ libSfx.name }}</option>
                                            </select>
                                        </template>
                                        <template v-else>
                                            <input type="text" v-model="sfx.name"
                                                class="bg-transparent outline-none border-b border-orange-300 hover:border-orange-400 text-orange-600 font-bold max-w-[100px]"
                                                title="æ­¤éŸ³æ•ˆå°šæœªç”Ÿæˆ">
                                            <button @click="generateMissingSfx(sfx, line)"
                                                class="px-2 py-0.5 bg-orange-500 text-white rounded hover:bg-orange-600 ml-1 font-bold text-[10px] shadow-sm disabled:opacity-50"
                                                :disabled="sfx._isGeneratingSfx">
                                                <span v-if="sfx._isGeneratingSfx" class="animate-pulse">ç”Ÿæˆä¸­...</span>
                                                <span v-else>âœ¨ MOSS ç”Ÿæˆ</span>
                                            </button>
                                        </template>
                                        <span class="text-slate-400">@</span>
                                        <input type="number" v-model="sfx.position" step="0.1" min="0" max="1"
                                            class="w-10 bg-transparent text-center outline-none border-b border-transparent hover:border-blue-300"
                                            title="è§¦å‘ä½ç½® (0.0 - 1.0)">
                                        <span class="text-slate-400 ml-1">ğŸ”‰</span>
                                        <input type="range" v-model="sfx.volume" min="0" max="1" step="0.05"
                                            class="w-14 h-3 accent-blue-500 cursor-pointer"
                                            :title="'éŸ³é‡: ' + Math.round((sfx.volume ?? 0.5) * 100) + '%'">
                                        <span class="text-[9px] text-slate-400 w-7">{{ Math.round((sfx.volume ?? 0.5) *
                                            100) }}%</span>
                                        <span class="text-slate-400 ml-1">âœ‚ï¸</span>
                                        <input type="number" v-model="sfx.trimStart" step="0.05" min="0"
                                            :max="sfx.trimEnd || 1"
                                            class="w-10 bg-transparent text-center outline-none border-b border-transparent hover:border-blue-300"
                                            title="è£å‰ªèµ·ç‚¹ (0.0 - 1.0)">
                                        <span class="text-slate-400">~</span>
                                        <input type="number" v-model="sfx.trimEnd" step="0.05" :min="sfx.trimStart || 0"
                                            max="1"
                                            class="w-10 bg-transparent text-center outline-none border-b border-transparent hover:border-blue-300"
                                            title="è£å‰ªç»ˆç‚¹ (0.0 - 1.0)">
                                        <button @click="removeLineSfx(line, sIdx)"
                                            class="ml-1 text-slate-400 hover:text-red-500 font-bold">Ã—</button>
                                    </div>
                                    <button @click="addLineSfx(line)"
                                        class="text-[10px] text-slate-400 hover:text-blue-600 border border-dashed border-slate-300 rounded px-2 py-1 hover:border-blue-400 transition-colors flex items-center gap-1">+
                                        éŸ³æ•ˆ</button>
                                </div>

                                <!-- æ–‡æœ¬ä¸éŸ³æ•ˆåŒºåŸŸ -->
                                <div class="w-full flex flex-col gap-2 min-w-0">
                                    <textarea v-model="line.text" rows="2"
                                        class="w-full h-full bg-transparent border-none focus:ring-0 text-sm text-slate-700 resize-none leading-relaxed py-1.5"
                                        @input="autoResizeTextarea($event)"></textarea>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- è°ƒè¯•ï¼šæ˜¾ç¤ºåŸå§‹ JSON -->
                <div v-if="rawAnalysisResult" class="bg-white p-5 rounded-xl border border-slate-200 shadow-sm">
                    <h3 class="text-sm font-bold text-slate-700 mb-2">3. AI åŸå§‹è¾“å‡º (è°ƒè¯•ç”¨)</h3>
                    <pre
                        class="bg-slate-800 text-slate-200 p-4 rounded-lg text-xs overflow-x-auto whitespace-pre-wrap max-h-64">{{ rawAnalysisResult }}</pre>
                </div>
            </div>
        </div>

        <!-- é¡µé¢ 7: Prompt ç®¡ç† -->
        <div v-if="activeTab === 'prompt'" class="space-y-6">
            <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-bold text-slate-700">è‡ªå®šä¹‰ Prompt æ¨¡æ¿</h3>
                    <div class="space-x-2">
                        <button @click="savePrompt"
                            class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">ä¿å­˜è®¾ç½®</button>
                        <button @click="resetPrompt"
                            class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">æ¢å¤é»˜è®¤</button>
                    </div>
                </div>

                <h4 class="text-sm font-bold text-slate-600 mb-2">1. å‰§æœ¬æ‹†åˆ†ä¸åˆ†æ Prompt</h4>
                <div class="flex items-center gap-2 mb-4 bg-white p-3 rounded-lg border border-slate-200">
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" v-model="useCustomPrompt" class="sr-only peer">
                        <div
                            class="w-11 h-6 bg-slate-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600">
                        </div>
                        <span class="ml-3 text-sm font-bold text-slate-700">å¯ç”¨è‡ªå®šä¹‰ Prompt</span>
                    </label>
                    <span class="text-xs text-slate-400 ml-2">(å…³é—­æ—¶å°†ä½¿ç”¨ç³»ç»Ÿå†…ç½®çš„é»˜è®¤ Prompt)</span>
                </div>

                <textarea v-model="customPromptTemplate" :disabled="!useCustomPrompt"
                    :class="['w-full h-[60vh] p-3 text-xs font-mono border rounded-lg focus:ring-2 focus:ring-blue-500 outline-none mb-3', !useCustomPrompt ? 'bg-slate-100 text-slate-400' : 'bg-white text-slate-700']"
                    spellcheck="false"></textarea>
                <div class="mt-2 text-xs text-slate-500">
                    <span class="font-bold">å¯ç”¨å˜é‡:</span> ${sfxSection}, ${bgmSection}, ${bgmExampleLine}, ${sfxExample},
                    ${rawScript}
                </div>

                <hr class="my-6 border-slate-200">

                <div class="flex justify-between items-center mb-2">
                    <h4 class="text-sm font-bold text-slate-600">2. è§’è‰²éŸ³è‰²åˆ†æ Prompt</h4>
                    <div class="space-x-2">
                        <button @click="saveVoicePrompt"
                            class="px-3 py-1.5 bg-blue-100 text-blue-700 rounded-lg text-xs font-bold hover:bg-blue-200 transition-all">ä¿å­˜éŸ³è‰²Prompt</button>
                        <button @click="resetVoicePrompt"
                            class="px-3 py-1.5 bg-slate-100 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-200 transition-all">æ¢å¤é»˜è®¤</button>
                    </div>
                </div>
                <div class="flex items-center gap-2 mb-4 bg-white p-3 rounded-lg border border-slate-200">
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" v-model="useCustomVoicePrompt" class="sr-only peer">
                        <div
                            class="w-11 h-6 bg-slate-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600">
                        </div>
                        <span class="ml-3 text-sm font-bold text-slate-700">å¯ç”¨è‡ªå®šä¹‰éŸ³è‰²åˆ†æ Prompt</span>
                    </label>
                    <span class="text-xs text-slate-400 ml-2">(å…³é—­æ—¶å°†ä½¿ç”¨ç³»ç»Ÿå†…ç½®çš„é»˜è®¤ Prompt)</span>
                </div>
                <textarea v-model="customVoicePromptTemplate" :disabled="!useCustomVoicePrompt"
                    :class="['w-full h-48 p-3 text-xs font-mono border rounded-lg focus:ring-2 focus:ring-blue-500 outline-none mb-3', !useCustomVoicePrompt ? 'bg-slate-100 text-slate-400' : 'bg-white text-slate-700']"
                    spellcheck="false"></textarea>
                <div class="mt-2 text-xs text-slate-500">
                    <span class="font-bold">å¯ç”¨å˜é‡:</span> ${charName}, ${rawScript}
                </div>

                <hr class="my-6 border-slate-200">

                <div class="flex justify-between items-center mb-2">
                    <h4 class="text-sm font-bold text-slate-600">3. Qwen éŸ³è‰²ç”Ÿæˆå‚è€ƒéŸ³é¢‘ æ–‡æœ¬æ¨¡æ¿</h4>
                    <div class="space-x-2">
                        <button @click="saveQwenVoiceText"
                            class="px-3 py-1.5 bg-pink-100 text-pink-700 rounded-lg text-xs font-bold hover:bg-pink-200 transition-all">ä¿å­˜ç”Ÿæˆæ–‡æœ¬</button>
                        <button @click="resetQwenVoiceText"
                            class="px-3 py-1.5 bg-slate-100 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-200 transition-all">æ¢å¤é»˜è®¤</button>
                    </div>
                </div>
                <div class="flex items-center gap-2 mb-4 bg-white p-3 rounded-lg border border-slate-200">
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" v-model="useCustomQwenVoiceText" class="sr-only peer">
                        <div
                            class="w-11 h-6 bg-slate-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600">
                        </div>
                        <span class="ml-3 text-sm font-bold text-slate-700">å¯ç”¨è‡ªå®šä¹‰ç”Ÿæˆæ–‡æœ¬</span>
                    </label>
                    <span class="text-xs text-slate-400 ml-2">(å…³é—­æ—¶å°†ä½¿ç”¨ç³»ç»Ÿå†…ç½®çš„é»˜è®¤æ–‡æœ¬)</span>
                </div>
                <textarea v-model="customQwenVoiceTextTemplate" :disabled="!useCustomQwenVoiceText"
                    :class="['w-full h-24 p-3 text-xs font-mono border rounded-lg focus:ring-2 focus:ring-blue-500 outline-none mb-3', !useCustomQwenVoiceText ? 'bg-slate-100 text-slate-400' : 'bg-white text-slate-700']"
                    spellcheck="false"></textarea>
                <div class="mt-2 text-xs text-slate-500">
                    <span class="font-bold">å¯ç”¨å˜é‡:</span> ${charName}
                </div>
            </div>
        </div>

        <!-- Voice Record/Upload Modal -->
        <div v-if="isRecordModalOpen"
            class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white p-6 rounded-xl w-[500px] max-w-full shadow-2xl">
                <h3 class="text-lg font-bold text-slate-800 mb-4 flex justify-between items-center">
                    ä¸ºã€Œ{{ recordTargetChar?.name }}ã€è®¾ç½®å‚è€ƒéŸ³é¢‘
                    <button @click="closeRecordModal"
                        class="text-slate-400 hover:text-red-500 text-2xl leading-none">&times;</button>
                </h3>

                <div class="mb-4">
                    <div class="flex gap-2 mb-4">
                        <input type="file" ref="voiceUploadRef" @change="handleUploadVoice" accept="audio/*"
                            class="hidden">
                        <button @click="$refs.voiceUploadRef.click()"
                            class="flex-1 px-4 py-2 bg-slate-100 text-slate-700 rounded-lg hover:bg-slate-200 font-bold transition-colors">
                            ğŸ“ ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶
                        </button>
                        <button v-if="recordState === 'idle'" @click="startRecording"
                            class="flex-1 px-4 py-2 bg-red-100 text-red-600 rounded-lg hover:bg-red-200 font-bold transition-colors flex justify-center items-center gap-2">
                            <span class="w-2 h-2 rounded-full bg-red-600"></span> å¼€å§‹éº¦å…‹é£å½•éŸ³
                        </button>
                        <button v-else-if="recordState === 'recording'" @click="stopRecording"
                            class="flex-1 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-bold transition-colors flex justify-center items-center gap-2 animate-pulse">
                            â¹ åœæ­¢å½•éŸ³
                        </button>
                        <button v-else @click="startRecording"
                            class="flex-1 px-4 py-2 bg-red-100 text-red-600 rounded-lg hover:bg-red-200 font-bold transition-colors flex justify-center items-center gap-2">
                            é‡æ–°å½•åˆ¶
                        </button>
                    </div>

                    <div v-show="recordAudioBuffer" class="bg-slate-50 p-4 rounded-xl border border-slate-200">
                        <p class="text-[10px] text-slate-500 mb-2 font-bold uppercase">éŸ³é¢‘ä¿®å‰ª (æ³¢å½¢é¢„è§ˆ) <span
                                v-if="recordAudioBuffer"
                                class="ml-2 font-normal">{{recordAudioBuffer.duration.toFixed(2)}} ç§’</span></p>
                        <!-- waveform container -->
                        <div class="relative w-full h-16 bg-slate-200 rounded overflow-hidden mb-2">
                            <canvas ref="recordWaveformCanvas" class="w-full h-full absolute inset-0"></canvas>
                            <!-- selection overlay -->
                            <div class="absolute top-0 bottom-0 bg-blue-500 bg-opacity-20 border-l-2 border-r-2 border-blue-600 pointer-events-none"
                                :style="'left:' + (recordTrimStart * 100) + '%; right:' + (100 - recordTrimEnd * 100) + '%'">
                            </div>
                        </div>

                        <div class="flex items-center gap-2 mb-3">
                            <span class="text-xs text-slate-400">âœ‚ï¸ è£å‰ªæ¯”ä¾‹ (0.0~1.0):</span>
                            <div class="flex-1">
                                <input type="range" v-model.number="recordTrimStart" step="0.01" min="0"
                                    :max="recordTrimEnd - 0.01"
                                    class="w-full h-1 bg-slate-300 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <span class="text-slate-400 text-xs">-</span>
                            <div class="flex-1">
                                <input type="range" v-model.number="recordTrimEnd" step="0.01"
                                    :min="recordTrimStart + 0.01" max="1"
                                    class="w-full h-1 bg-slate-300 rounded-lg appearance-none cursor-pointer">
                            </div>
                        </div>

                        <div class="flex gap-2">
                            <button @click="playTrimmedRecord"
                                class="px-3 py-1.5 bg-green-100 text-green-700 rounded text-xs font-bold hover:bg-green-200 flex items-center gap-1">
                                â–¶ è¯•å¬æˆªå–ç‰‡æ®µ
                            </button>
                            <button @click="stopTrimmedRecord"
                                class="px-3 py-1.5 bg-slate-200 text-slate-600 rounded text-xs font-bold hover:bg-slate-300">
                                â¹ åœæ­¢
                            </button>
                        </div>
                    </div>
                </div>

                <div class="flex justify-end gap-2 mt-6">
                    <button @click="closeRecordModal"
                        class="px-4 py-2 bg-slate-100 text-slate-600 font-bold rounded-lg hover:bg-slate-200 border border-slate-300">å–æ¶ˆ</button>
                    <button @click="saveRecordAndTrim" :disabled="!recordAudioBuffer || isSavingRecord"
                        class="px-4 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 disabled:opacity-50">
                        {{ isSavingRecord ? 'ä¿å­˜å¤„ç†ä¸­...' : 'ç¡®è®¤å¹¶è®¾ä¸ºéŸ³è‰²' }}
                    </button>
                </div>
            </div>
        </div>

    </div>

    <script>
        const { createApp, ref, onMounted, computed, watch, onBeforeUpdate } = Vue;

        createApp({
            setup() {
                // --- System Emotions Definition ---
                const SYSTEM_EMOTIONS = [
                    { id: 'sys_1', name: 'é«˜å…´', vector: [1, 0, 0, 0, 0, 0, 0, 0] },
                    { id: 'sys_2', name: 'ç”Ÿæ°”', vector: [0, 1, 0, 0, 0, 0, 0, 0] },
                    { id: 'sys_3', name: 'ä¼¤å¿ƒ', vector: [0, 0, 1, 0, 0, 0, 0, 0] },
                    { id: 'sys_4', name: 'å®³æ€•', vector: [0, 0, 0, 1, 0, 0, 0, 0] },
                    { id: 'sys_5', name: 'åŒæ¶', vector: [0, 0, 0, 0, 1, 0, 0, 0] },
                    { id: 'sys_6', name: 'ä½è½', vector: [0, 0, 0, 0, 0, 1, 0, 0] },
                    { id: 'sys_7', name: 'æƒŠå–œ', vector: [0, 0, 0, 0, 0, 0, 1, 0] },
                    { id: 'sys_8', name: 'å¹³é™', vector: [0, 0, 0, 0, 0, 0, 0, 1] }
                ];
                const isSystemEmotion = (name) => SYSTEM_EMOTIONS.some(e => e.name === name);

                // --- IndexedDB Persistence Logic ---
                const DB_NAME = 'UnitaleDB';
                const DB_VERSION = 1;
                let dbInstance = null;
                let dbPromise = null;

                const initDB = () => {
                    if (dbInstance) return Promise.resolve(dbInstance);
                    if (dbPromise) return dbPromise;

                    dbPromise = new Promise((resolve, reject) => {
                        const request = indexedDB.open(DB_NAME, DB_VERSION);
                        request.onerror = (e) => {
                            console.error('DB Error', e);
                            dbPromise = null;
                            reject(e);
                        };
                        request.onsuccess = (e) => {
                            dbInstance = e.target.result;
                            dbInstance.onclose = () => { dbInstance = null; dbPromise = null; };
                            dbInstance.onversionchange = () => { dbInstance.close(); dbInstance = null; dbPromise = null; };
                            resolve(dbInstance);
                        };
                        request.onupgradeneeded = (e) => {
                            const db = e.target.result;
                            if (!db.objectStoreNames.contains('project')) db.createObjectStore('project');
                            if (!db.objectStoreNames.contains('assets')) db.createObjectStore('assets');
                        };
                    });
                    return dbPromise;
                };

                const saveAssetToDB = async (key, blob) => {
                    try {
                        if (!dbInstance) await initDB();
                        return await new Promise((resolve, reject) => {
                            try {
                                const tx = dbInstance.transaction('assets', 'readwrite');
                                tx.objectStore('assets').put(blob, key);
                                tx.oncomplete = () => resolve();
                                tx.onerror = (e) => reject(e);
                            } catch (e) { reject(e); }
                        });
                    } catch (e) {
                        if (e.name === 'InvalidStateError' || (e.message && e.message.includes('closing'))) {
                            console.warn('DB connection closed, retrying saveAssetToDB...');
                            dbInstance = null;
                            dbPromise = null;
                            await initDB();
                            return new Promise((resolve, reject) => {
                                const tx = dbInstance.transaction('assets', 'readwrite');
                                tx.objectStore('assets').put(blob, key);
                                tx.oncomplete = () => resolve();
                                tx.onerror = (e) => reject(e);
                            });
                        }
                        throw e;
                    }
                };

                const loadAssetFromDB = async (key) => {
                    if (!dbInstance) await initDB();
                    return new Promise((resolve) => {
                        const tx = dbInstance.transaction('assets', 'readonly');
                        const req = tx.objectStore('assets').get(key);
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve(null);
                    });
                };

                const saveAssetsBatch = async (items) => {
                    if (!dbInstance) await initDB();

                    // 1. å»é‡
                    const uniqueMap = new Map();
                    items.forEach(item => uniqueMap.set(item.key, item.blob));
                    const entries = Array.from(uniqueMap.entries());

                    // 2. åˆ†å—ä¿å­˜ (Chunking) - å…³é”®ä¿®å¤ï¼šé¿å…ä¸€æ¬¡æ€§äº‹åŠ¡è¿‡å¤§å¯¼è‡´å´©æºƒ
                    const BATCH_SIZE = 5;

                    for (let i = 0; i < entries.length; i += BATCH_SIZE) {
                        const chunk = entries.slice(i, i + BATCH_SIZE);

                        // ä¸ºæ¯ä¸ªå—æ·»åŠ é‡è¯•æœºåˆ¶
                        let retries = 3;
                        while (retries > 0) {
                            try {
                                await new Promise((resolve, reject) => {
                                    const tx = dbInstance.transaction('assets', 'readwrite');
                                    const store = tx.objectStore('assets');
                                    tx.oncomplete = () => resolve();
                                    tx.onerror = (e) => reject(e);
                                    tx.onabort = (e) => reject(e);

                                    for (const [key, blob] of chunk) {
                                        store.put(blob, key);
                                    }
                                });
                                break; // æˆåŠŸåˆ™è·³å‡ºé‡è¯•å¾ªç¯
                            } catch (e) {
                                console.warn(`Batch save failed (chunk ${i}), retrying...`, e);
                                retries--;
                                if (retries === 0) throw e; // é‡è¯•è€—å°½ï¼ŒæŠ›å‡ºé”™è¯¯
                                // å°è¯•é‡ç½®è¿æ¥
                                dbInstance = null;
                                dbPromise = null;
                                await initDB();
                            }
                        }
                    }
                };

                const saveProjectToDB = async () => {
                    if (!dbInstance) await initDB();

                    // Prepare data (exclude blobs from JSON, they are in assets store)
                    // ä½¿ç”¨ JSON åºåˆ—åŒ–æ·±æ‹·è´ï¼Œå»é™¤ Vue çš„ Proxy ä»£ç†å¯¹è±¡ï¼Œé˜²æ­¢ IndexedDB æŠ¥é”™ DataCloneError
                    const plainScriptLines = scriptLines.value.map(l => {
                        // Don't save audioUrl (blob url), just the ID implies existence of line_audio_{id}
                        const { audioUrl, isGenerating, ...rest } = l;
                        return rest;
                    });

                    const projectData = JSON.parse(JSON.stringify({
                        rawScript: rawScript.value,
                        rawAnalysisResult: rawAnalysisResult.value,
                        characters: characters.value,
                        scriptLines: plainScriptLines,
                        libraries: {
                            sfx: sfxLibrary.value,
                            bgm: bgmLibrary.value,
                            timbres: timbres.value,
                            filters: filterLibrary.value,
                            emotions: emotionPresets.value
                        },
                        timestamp: Date.now()
                    }));

                    return new Promise((resolve, reject) => {
                        const tx = dbInstance.transaction('project', 'readwrite');
                        tx.objectStore('project').put(projectData, 'currentState');
                        tx.oncomplete = () => resolve();
                        tx.onerror = (e) => reject(e);
                    });
                };

                let saveTimeout = null;
                const triggerAutoSave = () => {
                    if (saveTimeout) clearTimeout(saveTimeout);
                    saveTimeout = setTimeout(() => {
                        saveProjectToDB().catch(e => console.warn('Auto-save failed', e));
                    }, 1000);
                };

                // çŠ¶æ€
                const activeTab = ref('script');

                watch(activeTab, (newValue) => {
                    localStorage.setItem('storyforge_activeTab', newValue);
                });
                const llmConfigs = ref([]);
                const currentConfigId = ref('');

                watch(currentConfigId, (newId) => {
                    if (newId) localStorage.setItem('unitale_llmConfigId', newId);
                });

                // è¡¨å•çŠ¶æ€
                const form = ref({ id: '', name: '', baseUrl: '', model: '', key: '', params: '' });
                const isEditing = ref(false);

                // TTS é…ç½®çŠ¶æ€
                const ttsConfigs = ref([]);
                const ttsForm = ref({ id: '', name: '', baseUrl: '' });
                const isEditingTts = ref(false);

                // è§’è‰²åº“çŠ¶æ€
                const characters = ref([]);

                // å½•éŸ³/ä¸Šä¼ å‚è€ƒéŸ³é¢‘çŠ¶æ€
                const isRecordModalOpen = ref(false);
                const recordTargetChar = ref(null);
                const recordState = ref('idle'); // 'idle', 'recording', 'recorded'
                const recordAudioBuffer = ref(null);
                const recordTrimStart = ref(0);
                const recordTrimEnd = ref(1);
                const isSavingRecord = ref(false);
                const recordWaveformCanvas = ref(null);
                let mediaRecorder = null;
                let audioChunks = [];
                let recordPreviewSource = null;

                // éŸ³è‰²åº“çŠ¶æ€
                const timbres = ref([]);
                const timbreForm = ref({ id: '', name: '', description: '', refPath: '' });
                const isEditingTimbre = ref(false);
                const selectedTimbreId = ref('');
                const timbreFile = ref(null); // ADDED: To store the selected timbre file object

                // æƒ…ç»ªé¢„è®¾çŠ¶æ€
                const emotionPresets = ref([]);
                const emotionForm = ref({ id: '', name: '', vector: [0, 0, 0, 0, 0, 0, 0, 0] });
                const isEditingEmotion = ref(false);

                // éŸ³æ•ˆåº“çŠ¶æ€
                const sfxLibrary = ref([]);
                const sfxForm = ref({ id: '', name: '', description: '', filename: '' });
                const isEditingSfx = ref(false);
                // AI éŸ³æ•ˆç”ŸæˆçŠ¶æ€
                const sfxGenForm = ref({ description: '', duration: 5, name: '' });
                const isGeneratingSfx = ref(false);

                // BGMåº“çŠ¶æ€
                const bgmLibrary = ref([]);
                const bgmForm = ref({ id: '', name: '', description: '', filename: '' });
                const isEditingBgm = ref(false);

                // æ»¤æ³¢å™¨åº“çŠ¶æ€
                const filterLibrary = ref([]);
                const filterForm = ref({ id: '', name: '', description: '', type: 'lowpass', frequency: 1000, Q: 1, gain: 0 });
                const isEditingFilter = ref(false);

                // èŠå¤©çŠ¶æ€
                const prompt = ref('');
                const result = ref('');
                const reasoning = ref('');
                const error = ref('');
                const loading = ref(false);
                const abortController = ref(null);

                // TTS çŠ¶æ€
                const currentTtsConfigId = ref('');

                watch(currentTtsConfigId, (newId) => {
                    if (newId) localStorage.setItem('unitale_ttsConfigId', newId);
                });

                const ttsRefFile = ref(null);
                const ttsRefPath = ref('uploaded/ref.wav'); // é»˜è®¤è·¯å¾„ç¤ºä¾‹
                const ttsEmoText = ref('ä¸­ç«‹');
                const audioUrl = ref('');
                const ttsLoading = ref(false);
                const ttsError = ref('');
                const ttsAbortController = ref(null);

                // è„šæœ¬åˆ¶ä½œçŠ¶æ€
                const rawScript = ref('');
                const scriptLines = ref([]);
                const isAnalyzingScript = ref(false);
                const rawAnalysisResult = ref('');
                const analysisAbortController = ref(null);
                const selectedLineIndex = ref(-1);
                const isGeneratingAll = ref(false);
                const isSequencePlaying = ref(false);
                const currentSequenceIndex = ref(-1);
                const lineRefs = ref([]);
                const scriptListContainer = ref(null);
                onBeforeUpdate(() => {
                    lineRefs.value = [];
                });
                let sequenceAbortController = null;
                const isExportingAudio = ref(false);
                const importFileRef = ref(null);
                const importTxtRef = ref(null);
                const isExportingProject = ref(false);
                const exportStatus = ref('');
                let bgmAudioNode = null;
                let bgmGainNode = null;
                const playbackProgress = ref(0);
                let playbackAnimationFrame = null;

                // å‰ªè¾‘æ‹–æ‹½çŠ¶æ€
                const draggingTrimState = ref(null);

                // è®¡ç®—å½“å‰é€‰ä¸­çš„é…ç½®
                const currentConfig = computed(() => {
                    return llmConfigs.value.find(c => c.id === currentConfigId.value) || null;
                });

                // Prompt Template
                const defaultPromptTemplate = `ä½ çš„ä»»åŠ¡æ˜¯å°†ç»™å®šå°è¯´å†…å®¹æ‹†åˆ†ä¸ºå°è¯å’Œæ—ç™½ï¼Œå¹¶è‡ªåŠ¨è¯†åˆ«æ¯ä¸€å¥å°è¯çš„è§’è‰²å’Œæƒ…ç»ªã€‚
**æ³¨æ„ï¼šç”Ÿæˆçš„ç»“æœå°†ç›´æ¥ç”¨äº IndexTTS è¯­éŸ³åˆæˆç³»ç»Ÿï¼Œè¯·ä¸¥æ ¼ä»æŒ‡å®šçš„æƒ…ç»ªåˆ—è¡¨ä¸­é€‰æ‹©ï¼Œä¸è¦è‡ªè¡Œç”Ÿæˆæƒ…ç»ªæè¿°æ–‡æœ¬ã€‚**

\${sfxSection}

\${bgmSection}

\${filterSection}

# æƒ…ç»ªä¸å¼ºåº¦è®¾ç½® (Emotion & Intensity)
è¯·ä¸ºæ¯ä¸€å¥å°è¯ï¼ˆåŒ…æ‹¬æ—ç™½ï¼‰é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„æƒ…ç»ªå’Œå¼ºåº¦ã€‚

1. **å¯é€‰æƒ…ç»ª (Emotion)**: \${emotionList}
   - **æ³¨æ„**: å¿…é¡»ä¸¥æ ¼ä»ä¸Šè¿°åˆ—è¡¨ä¸­é€‰æ‹©ï¼Œ**ä¸¥ç¦**ç¼–é€ åˆ—è¡¨ä¹‹å¤–çš„æƒ…ç»ªåç§°ã€‚
   - æ—ç™½é€šå¸¸é€‰æ‹© "å¹³é™"ï¼Œä¹Ÿå¯æ ¹æ®æ°›å›´é€‰æ‹©å…¶ä»–æƒ…ç»ªã€‚

2. **å¯é€‰å¼ºåº¦ (Intensity)**: å¾®å¼±, ç¨å¼±, ä¸­ç­‰, è¾ƒå¼º, å¼ºçƒˆ
   - è¯·æ ¹æ®ä¸Šä¸‹æ–‡åˆ¤æ–­æƒ…ç»ªçš„å¼ºçƒˆç¨‹åº¦ã€‚
   - **æ—ç™½å¼ºåº¦**: å¦‚æœæ—ç™½æœ‰æƒ…ç»ªï¼ˆå¦‚ä¼¤å¿ƒã€å®³æ€•ï¼‰ï¼Œå¼ºåº¦å¿…é¡»å¾ˆå¼±ï¼ˆå»ºè®®é€‰æ‹© "å¾®å¼±" æˆ– "ç¨å¼±"ï¼‰ã€‚å¦‚æœæ—ç™½æ˜¯ "å¹³é™" æƒ…ç»ªï¼Œå¼ºåº¦åº”ä¸º "ä¸­ç­‰"ã€‚

# è§„åˆ™

## 1. æ‹†åˆ†ä¸è¯†åˆ«
- **å®Œæ•´ä¿ç•™**: å¿…é¡»å®Œæ•´ä¿ç•™åŸæ–‡å†…å®¹ï¼Œä¸å¾—é—æ¼ã€åˆ æ”¹æˆ–çœç•¥ä»»ä½•å­—å¥ã€‚
- **ä¸¥ç¦åˆ æ”¹**: **ç»å¯¹ç¦æ­¢**åˆ é™¤åŸæ–‡ä¸­çš„è¯´è¯äººæç¤ºè¯­ï¼ˆå¦‚â€œä»–ä½å£°è¯´â€ã€â€œç¬‘ç€é—®é“â€ï¼‰ã€‚è¿™äº›å†…å®¹å¿…é¡»ä½œä¸ºâ€œæ—ç™½â€å•ç‹¬æå–å‡ºæ¥ã€‚
- **å†…å®¹æå–**: æå–å¯¹è¯å†…å®¹å’Œæ‰€æœ‰éå¯¹è¯çš„æ—ç™½ã€‚
- **è§’è‰²è¯†åˆ«**: æ ¹æ®å°è¯´å†…å®¹åˆ†æè¯´è¯äººã€‚æ—ç™½çš„è§’è‰²åç»Ÿä¸€æ ‡è®°ä¸ºâ€œæ—ç™½â€ã€‚
- **é•¿åº¦æ§åˆ¶**: æ–‡æœ¬æ‹†åˆ†é•¿åº¦è¦é€‚ä¸­ã€‚**é¿å…è¿‡ç¢**ï¼ˆä¸è¦æŠŠæ¯ä¸€å¥çŸ­å¥éƒ½æ‹†æˆç‹¬ç«‹ä¸€è¡Œï¼‰ï¼Œä¹Ÿ**é¿å…è¿‡é•¿**ï¼ˆå•è¡Œæ–‡æœ¬å»ºè®®ä¸è¶…è¿‡ 50-80 å­—ï¼Œè¿‡é•¿çš„æ—ç™½è¯·åœ¨å¥å·å¤„é€‚å½“æ‹†åˆ†ï¼‰ã€‚
- **æ—ç™½å¤„ç†**: è¿ç»­çš„æ—ç™½å†…å®¹åº”ä¼˜å…ˆåˆå¹¶ï¼Œé™¤éä¸­é—´éœ€è¦æ’å…¥éŸ³æ•ˆã€æœ‰æ˜æ˜¾çš„æ—¶é—´è·³è·ƒï¼Œæˆ–åˆå¹¶åé•¿åº¦è¿‡é•¿ã€‚

## 3. éŸ³æ•ˆæ’å…¥ (sfx)
- å¦‚æœæƒ…èŠ‚éœ€è¦ï¼ˆå¦‚â€œæ‘”é—¨è€Œå»â€ã€â€œé›·å£°å¤§ä½œâ€ï¼‰ï¼Œå¯ä»¥åœ¨ JSON å¯¹è±¡ä¸­æ·»åŠ  \`sfx\` å­—æ®µã€‚
- **çµæ´»åŒ¹é…ä¸ç”Ÿæˆ**: ä¼˜å…ˆä½¿ç”¨ã€éŸ³æ•ˆåº“ã€‘ä¸­åˆ—å‡ºçš„åç§°ã€‚å¦‚æœåº“ä¸­æ²¡æœ‰åˆé€‚çš„ï¼Œä½ å¯ä»¥**ç›´æ¥ç”¨ç²¾ç‚¼çš„è¯è¯­ï¼ˆå¦‚â€œä¸‹é›¨å£°â€ã€â€œå…³é—¨å£°â€ï¼‰**ä½œä¸ºæ–°éŸ³æ•ˆçš„å±æ€§åï¼Œåç»­ç³»ç»Ÿå‘ç°åŒ¹é…ä¸åˆ°åï¼Œå…è®¸ç”¨æˆ·å€ŸåŠ© AI è‡ªåŠ¨è¡¥å…¨ç”Ÿæˆï¼
- **ç¦æ­¢æ··ç”¨**: **ç»å¯¹ç¦æ­¢**åœ¨ \`sfx\` å­—æ®µä¸­ä½¿ç”¨ã€èƒŒæ™¯éŸ³ä¹åº“ã€‘ä¸­çš„åç§°ã€‚SFX åªèƒ½ä½¿ç”¨ã€éŸ³æ•ˆåº“ã€‘çš„å†…å®¹æˆ–ä½ æ–°ç¼–é€ çš„ç²¾ç‚¼æè¿°ã€‚
- **æ”¯æŒå¤šéŸ³æ•ˆ**: ä¸€å¥å°è¯ä¸­å¯ä»¥æ’å…¥å¤šä¸ªéŸ³æ•ˆï¼Œåªè¦ä½ç½®åˆç†ï¼ˆå¦‚å¼€å¤´å…³é—¨ï¼Œä¸­é—´è„šæ­¥å£°ï¼‰ã€‚
- æ ¼å¼: \`"sfx": [{"name": "éŸ³æ•ˆåç§°", "position": 0.5, "trimStart": 0, "trimEnd": 1, "volume": 0.5}, ...]\`
- \`position\`: 0.0-1.0 ä¹‹é—´çš„æµ®ç‚¹æ•°ï¼Œè¡¨ç¤ºéŸ³æ•ˆåœ¨**å°è¯å¿µç™½æ—¶é•¿å†…**çš„æ’å…¥ä½ç½®ï¼ˆä¾‹å¦‚ 0.0 ä¸ºå¼€å§‹ï¼Œ1.0 ä¸ºå¿µç™½ç»“æŸï¼‰ã€‚
- \`trimStart\` ä¸ \`trimEnd\`: 0.0-1.0 ä¹‹é—´çš„æµ®ç‚¹æ•°ï¼Œä»£è¡¨ä½ éœ€è¦è£å‰ªåŸå§‹éŸ³æ•ˆæ–‡ä»¶çš„æ—¶é—´ä¿ç•™æ®µã€‚ä¾‹å¦‚åªéœ€ååŠæˆªåˆ™æ˜¯ \`"trimStart": 0.5, "trimEnd": 1.0\`ã€‚å¦‚æœä¸ä¿®å‰ªè¯·é»˜è®¤ä¿ç•™ \`"trimStart": 0, "trimEnd": 1\`ã€‚
- \`volume\`: 0.0-1.0 ä¹‹é—´çš„æµ®ç‚¹æ•°ï¼Œæ§åˆ¶è¯¥éŸ³æ•ˆçš„ç‹¬ç«‹éŸ³é‡æ¯”ä¾‹ï¼Œé»˜è®¤ 0.5ã€‚
- **é‡è¦**: \`position\` è®¡ç®—**ä¸åŒ…å«** \`break_duration\`ï¼ˆåœé¡¿æ—¶é—´ï¼‰ã€‚å³ 1.0 ä»£è¡¨å°è¯è¯´å®Œçš„é‚£ä¸€åˆ»ï¼Œè€Œä¸æ˜¯åœé¡¿ç»“æŸçš„é‚£ä¸€åˆ»ã€‚
- **é—´éš”éŸ³æ•ˆ**: å¦‚æœéŸ³æ•ˆå‘ç”Ÿåœ¨å°è¯åçš„åœé¡¿æœŸé—´ï¼Œè¯·å°†å…¶åŠ å…¥è¯¥å°è¯çš„ \`sfx\` åˆ—è¡¨ï¼Œä½ç½®è®¾ä¸º 1.0ã€‚
- **ç‰¹åˆ«é‡è¦** å°½é‡ç»™æ¯å¥éƒ½é…ä¸Šåˆé€‚çš„SFXéŸ³æ•ˆï¼Œå¦‚æœæœ‰çš„è¯

## 4. èƒŒæ™¯éŸ³ä¹æ§åˆ¶ (BGM Control)
- **å¼€å¤´BGM**: è¯·**åŠ¡å¿…**åœ¨è„šæœ¬çš„æœ€å¼€å§‹å°è¯•åŒ¹é…å¹¶æ’å…¥ä¸€ä¸ªé€‚åˆå½“å‰æ°›å›´çš„ BGMã€‚åªè¦ã€èƒŒæ™¯éŸ³ä¹åº“ã€‘ä¸­æœ‰åˆé€‚çš„ï¼Œå°±**å¿…é¡»**æ’å…¥ã€‚
- å½“å‰§æƒ…æ°›å›´å‘ç”Ÿå˜åŒ–ï¼Œéœ€è¦åˆ‡æ¢æˆ–åœæ­¢èƒŒæ™¯éŸ³ä¹æ—¶ï¼Œè¯·æ’å…¥ä¸€ä¸ªç‹¬ç«‹çš„ BGM æ§åˆ¶å¯¹è±¡ã€‚
- **æ ¼å¼**: \`{"type": "bgm", "action": "play", "name": "BGMåç§°"}\` æˆ– \`{"type": "bgm", "action": "stop"}\`
- **ä¸¥æ ¼é™åˆ¶**:
  - \`name\` å­—æ®µ**å¿…é¡»å®Œå…¨ç­‰äº**ã€èƒŒæ™¯éŸ³ä¹åº“ã€‘ä¸­åˆ—å‡ºçš„æŸä¸€ä¸ªåç§°ã€‚
  - **ç¦æ­¢æ··ç”¨**: **ç»å¯¹ç¦æ­¢**åœ¨ BGM æ§åˆ¶å—ä¸­ä½¿ç”¨ã€éŸ³æ•ˆåº“ã€‘ä¸­çš„åç§°ã€‚BGM åªèƒ½ä½¿ç”¨ã€èƒŒæ™¯éŸ³ä¹åº“ã€‘çš„å†…å®¹ã€‚
  - å¦‚æœã€èƒŒæ™¯éŸ³ä¹åº“ã€‘ä¸ºç©ºï¼Œæˆ–è€…æ²¡æœ‰åŒ¹é…çš„éŸ³ä¹ï¼Œ**ç»å¯¹ä¸è¦**ç”Ÿæˆ action="play" çš„æ§åˆ¶å—ã€‚
  - ç¦æ­¢ä½¿ç”¨ "MysteriousBGM", "SadPiano" ç­‰ç¤ºä¾‹ä¸­å‡ºç°ä½†åº“é‡Œæ²¡æœ‰çš„åç§°ã€‚
- **æ³¨æ„**: ä¸è¦å°† bgm å­—æ®µæ”¾åœ¨å°è¯å¯¹è±¡ä¸­ã€‚
- è¯·å¤šåˆ‡æ¢BGMï¼Œä½“ç°å¤šæ ·æ€§

- **åœé¡¿æ—¶é—´**: åˆ†æå°è¯åçš„å‰§æƒ…èŠ‚å¥ï¼Œè®¾ç½®è¯¥å°è¯ç»“æŸåçš„åœé¡¿æ—¶é—´ï¼ˆç§’ï¼‰ã€‚
- é»˜è®¤ä¸º 0ã€‚å¦‚æœæœ‰åŠ¨ä½œæå†™æˆ–å¿ƒç†æ´»åŠ¨æš—ç¤ºåœé¡¿ï¼Œè¯·è®¾ç½®ç›¸åº”æ—¶é•¿ï¼ˆå¦‚ 0.5, 1.0, 2.0ï¼‰ã€‚
- ç¤ºä¾‹: ä¸¤äººå¯¹è¯é—´çš„å°´å°¬æ²‰é»˜ï¼Œæˆ–åŠ¨ä½œæå†™ï¼ˆå¦‚â€œä»–å–äº†ä¸€å£èŒ¶â€ï¼‰éœ€è¦çš„æ—¶é—´ã€‚

## 5. éŸ³é¢‘æ»¤æ³¢å™¨ (Filter)
- å¦‚æœå‰§æƒ…ç¯å¢ƒç‰¹æ®Šï¼ˆå¦‚â€œåœ¨æ°´ä¸‹è¯´è¯â€ã€â€œç”µè¯é€šè¯ä¸­â€ã€â€œå›å¿†/å†…å¿ƒç‹¬ç™½â€ï¼‰ï¼Œä¸”ã€æ»¤æ³¢å™¨åº“ã€‘ä¸­æœ‰å¯¹åº”æ•ˆæœï¼Œè¯·åœ¨å°è¯å¯¹è±¡ä¸­æ·»åŠ  \`filter\` å­—æ®µã€‚
- **æ ¼å¼**: \`"filter": "æ»¤æ³¢å™¨åç§°"\`
- **ä¸¥æ ¼é™åˆ¶**: å¿…é¡»ä½¿ç”¨ã€æ»¤æ³¢å™¨åº“ã€‘ä¸­å­˜åœ¨çš„åç§°ã€‚å¦‚æœæ²¡æœ‰åŒ¹é…é¡¹ï¼Œ**ä¸è¦**ç”Ÿæˆæ­¤å­—æ®µã€‚
- **ç‰¹åˆ«æé†’**: å¦‚æœè§’è‰²æ˜¯â€œæ—ç™½â€ï¼Œ**åƒä¸‡ä¸è¦**ä½¿ç”¨æ»¤æ³¢å™¨åŠŸèƒ½ã€‚

## 6. è¾“å‡ºæ ¼å¼
- **ä¸¥æ ¼ JSON**: è¾“å‡ºæ ¼å¼å¿…é¡»æ˜¯ä¸¥æ ¼çš„ JSON æ•°ç»„ï¼Œä¸åŒ…å«ä»»ä½•é¢å¤–è¯´æ˜æˆ–ä»£ç å—æ ‡è®°ã€‚
- **æ•°ç»„å…ƒç´ **: å¿…é¡»æ˜¯ä»¥ä¸‹ä¸¤ç§å¯¹è±¡ä¹‹ä¸€ï¼š
  1. **å°è¯å¯¹è±¡**: \`{"type": "dialogue", "role_name": "...", "text_content": "...", "emotion": "...", "intensity": "...", "break_duration": 0, "filter": "...", "sfx": [...]}\`
  2. **BGMå¯¹è±¡**: \`{"type": "bgm", "action": "play", "name": "..."}\` æˆ– \`{"type": "bgm", "action": "stop"}\`
  - **ä¸¥ç¦ç”Ÿæˆ** \`{"type": "sfx", ...}\` è¿™ç§ç‹¬ç«‹éŸ³æ•ˆå—ã€‚éŸ³æ•ˆå¿…é¡»åŒ…å«åœ¨å°è¯å¯¹è±¡çš„ \`sfx\` å­—æ®µä¸­ã€‚


## å°è¯´åŸæ–‡:
<novel_content>
â€œåˆ«æ¥é‚£ä¸ªç”µè¯ï¼â€è€æçŒ›åœ°æŒ‰ä½äº†æˆ‘çš„æ‰‹ï¼Œè„¸è‰²æƒ¨ç™½ï¼Œâ€œé‚£æ˜¯æ˜¨æ™šå€¼ç­çš„å°å¼ æ‰“æ¥çš„ã€‚â€
æˆ‘æ„£ä½äº†ï¼Œçœ‹ç€åŠå…¬æ¡Œä¸Šç–¯ç‹‚éœ‡åŠ¨çš„åº§æœºï¼šâ€œå¯æ˜¯â€¦â€¦å°å¼ ä¸æ˜¯ä»Šæ—©å·²ç»ç¡®è®¤æ­»äº¡äº†å—ï¼Ÿâ€
â€œå¯¹ï¼Œâ€è€æçš„å£°éŸ³åœ¨å‘æŠ–ï¼Œâ€œæ‰€ä»¥ï¼Œåˆ«æ¥ã€‚å¦‚æœä½ æ¥äº†ï¼Œä»–ä¼šé—®ä½ ä¸ºä»€ä¹ˆä¸æ•‘ä»–ã€‚â€
</novel_content>

## è¾“å‡º:
[
\${bgmExampleLine}
  {"type": "dialogue", "role_name": "è€æ", "text_content": "åˆ«æ¥é‚£ä¸ªç”µè¯ï¼", "emotion": "å®³æ€•", "intensity": "å¼ºçƒˆ", "break_duration": 0},
  {"type": "dialogue", "role_name": "æ—ç™½", "text_content": "è€æçŒ›åœ°æŒ‰ä½äº†æˆ‘çš„æ‰‹ï¼Œè„¸è‰²æƒ¨ç™½ï¼Œ", "emotion": "å¹³é™", "intensity": "ä¸­ç­‰", "break_duration": 0},
  {"type": "dialogue", "role_name": "è€æ", "text_content": "é‚£æ˜¯æ˜¨æ™šå€¼ç­çš„å°å¼ æ‰“æ¥çš„ã€‚", "emotion": "å®³æ€•", "intensity": "è¾ƒå¼º", "break_duration": 0.5},
  {"type": "dialogue", "role_name": "æ—ç™½", "text_content": "æˆ‘æ„£ä½äº†ï¼Œçœ‹ç€åŠå…¬æ¡Œä¸Šç–¯ç‹‚éœ‡åŠ¨çš„åº§æœºï¼š", "emotion": "å¹³é™", "intensity": "ä¸­ç­‰", "break_duration": 0\${sfxExample}},
  {"type": "dialogue", "role_name": "æˆ‘", "text_content": "å¯æ˜¯â€¦â€¦å°å¼ ä¸æ˜¯ä»Šæ—©å·²ç»ç¡®è®¤æ­»äº¡äº†å—ï¼Ÿ", "emotion": "æƒŠå–œ", "intensity": "å¾®å¼±", "break_duration": 0.5},
  {"type": "dialogue", "role_name": "è€æ", "text_content": "å¯¹ï¼Œ", "emotion": "ä½è½", "intensity": "ä¸­ç­‰", "break_duration": 0},
  {"type": "dialogue", "role_name": "æ—ç™½", "text_content": "è€æçš„å£°éŸ³åœ¨å‘æŠ–ï¼Œ", "emotion": "å¹³é™", "intensity": "ä¸­ç­‰", "break_duration": 0},
  {"type": "dialogue", "role_name": "è€æ", "text_content": "æ‰€ä»¥ï¼Œåˆ«æ¥ã€‚å¦‚æœä½ æ¥äº†ï¼Œä»–ä¼šé—®ä½ ä¸ºä»€ä¹ˆä¸æ•‘ä»–ã€‚", "emotion": "å®³æ€•", "intensity": "å¼ºçƒˆ", "break_duration": 0}
]

# è¾“å…¥å†…å®¹

## å°è¯´åŸæ–‡:
<novel_content>
\${rawScript}
</novel_content>`;

                const customPromptTemplate = ref(defaultPromptTemplate);
                const useCustomPrompt = ref(false);

                const defaultVoicePromptTemplate = `è¯·æ ¹æ®ä»¥ä¸‹å°è¯´ç‰‡æ®µï¼Œç®€è¦æè¿°è§’è‰²â€œ\${charName}â€çš„éŸ³è‰²ç‰¹å¾ã€‚\nè¦æ±‚ï¼šå¿…é¡»è¦å¸¦ä¸Šæ€§åˆ«ï¼Œå¯¹éŸ³è‰²çš„æè¿°æ–‡æœ¬éå¸¸ç²¾ç‚¼ï¼Œæ§åˆ¶åœ¨20å­—ä»¥å†…ã€‚é‡ç‚¹æè¿°å£°éŸ³çš„ç‰©ç†è´¨æ„Ÿï¼ˆå¦‚å£°çº¿ç²—ç»†ã€å¹´é¾„æ„Ÿã€æ²™å“‘/æ¸…è„†ç­‰ï¼‰ï¼Œä¸è¦åŒ…å«è¿‡å¤šçš„æ€§æ ¼æˆ–æƒ…ç»ªæå†™ã€‚ç›´æ¥è¾“å‡ºæè¿°ï¼Œä¸è¦åºŸè¯ã€‚\n\nå°è¯´ç‰‡æ®µï¼š\n\${rawScript}`;

                const customVoicePromptTemplate = ref(defaultVoicePromptTemplate);
                const useCustomVoicePrompt = ref(false);

                const defaultQwenVoiceTextTemplate = "æˆ‘æ˜¯${charName}ï¼Œåˆæ¬¡è§é¢ï¼Œè¯·å¤šå¤šæŒ‡æ•™ã€‚æ­£åœ¨è¿›è¡Œå£°çº¿æ ¡å‡†æµ‹è¯•ï¼Œä¸€ï¼ŒäºŒï¼Œä¸‰ã€‚è¿™æ®µéŸ³é¢‘å°†ä½œä¸ºæˆ‘çš„åŸºå‡†éŸ³è‰²ï¼Œå¸Œæœ›èƒ½å®Œç¾æ¼”ç»æ¥ä¸‹æ¥çš„æ•…äº‹ï¼Œè¯·å¤šå…³ç…§ã€‚";
                const customQwenVoiceTextTemplate = ref(defaultQwenVoiceTextTemplate);
                const useCustomQwenVoiceText = ref(false);

                // --- éŸ³é¢‘å¼•æ“ä¸ç¼“å­˜ (Audio Engine & Cache) ---
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBufferCache = new Map();
                const localFileMap = ref(new Map());

                const loadAudioBuffer = async (filename) => {
                    if (!filename) return null;
                    if (audioBufferCache.has(filename)) return audioBufferCache.get(filename);

                    try {
                        let arrayBuffer;
                        if (localFileMap.value.has(filename)) {
                            arrayBuffer = await localFileMap.value.get(filename).arrayBuffer();
                        } else if (filename.match(/^(https?:\/\/|blob:)/)) {
                            const res = await fetch(filename);
                            if (!res.ok) throw new Error(`Failed to fetch ${filename}`);
                            arrayBuffer = await res.arrayBuffer();
                        } else {
                            throw new Error(`Audio file not found in memory: ${filename}`);
                        }
                        const buffer = await audioContext.decodeAudioData(arrayBuffer);
                        audioBufferCache.set(filename, buffer);
                        return buffer;
                    } catch (e) {
                        console.warn(`Failed to load audio: ${filename}`, e);
                        return null;
                    }
                };

                // --- é¢„è§ˆæ’­æ”¾é€»è¾‘ ---
                const previewPlayingFile = ref(null);
                let previewSource = null;

                const playPreview = async (filename) => {
                    if (audioContext.state === 'suspended') await audioContext.resume();

                    if (previewSource) {
                        try { previewSource.stop(); } catch (e) { }
                        previewSource = null;
                    }

                    if (previewPlayingFile.value === filename) {
                        previewPlayingFile.value = null;
                        return;
                    }

                    if (!filename) return;

                    const buffer = await loadAudioBuffer(filename);
                    if (buffer) {
                        previewSource = audioContext.createBufferSource();
                        previewSource.buffer = buffer;
                        previewSource.connect(audioContext.destination);
                        previewSource.onended = () => {
                            if (previewPlayingFile.value === filename) previewPlayingFile.value = null;
                        };
                        previewSource.start();
                        previewPlayingFile.value = filename;
                    }
                };

                const preloadAudioAssets = async () => {
                    // ç§»é™¤å¯åŠ¨æ—¶çš„è‡ªåŠ¨é¢„åŠ è½½ï¼Œå› ä¸ºç°åœ¨æ²¡æœ‰æŒä¹…åŒ–çš„æ–‡ä»¶åˆ—è¡¨
                    // ä»…åœ¨å¯¼å…¥å·¥ç¨‹åæˆ–æ·»åŠ æ–‡ä»¶æ—¶åŠ è½½
                };

                // --- æ³¢å½¢ç»˜åˆ¶ä¸å‰ªè¾‘é€»è¾‘ ---
                const drawWaveform = async (canvas, line) => {
                    if (!canvas || !line.audioUrl) return;

                    // æ€§èƒ½ä¼˜åŒ–ï¼šå¦‚æœ URL æ²¡å˜ï¼Œä¸” Canvas å·²ç»ç»˜åˆ¶è¿‡ï¼Œåˆ™è·³è¿‡é‡ç»˜
                    if (canvas._lastUrl === line.audioUrl) return;
                    canvas._lastUrl = line.audioUrl;

                    const buffer = await loadAudioBuffer(line.audioUrl);
                    if (!buffer) return;

                    const ctx = canvas.getContext('2d');
                    const width = canvas.width;
                    const height = canvas.height;
                    const data = buffer.getChannelData(0);
                    const step = Math.ceil(data.length / width);
                    const amp = height / 2;

                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#94a3b8'; // slate-400
                    ctx.beginPath();

                    for (let i = 0; i < width; i++) {
                        let min = 1.0;
                        let max = -1.0;
                        for (let j = 0; j < step; j++) {
                            const datum = data[(i * step) + j];
                            if (datum < min) min = datum;
                            if (datum > max) max = datum;
                        }
                        ctx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
                    }
                };

                const startDragTrim = (e, line, type) => {
                    draggingTrimState.value = {
                        lineId: line.id,
                        type: type, // 'start' or 'end'
                        startX: e.clientX,
                        containerWidth: e.target.closest('.relative').offsetWidth,
                        startVal: type === 'start' ? (line.trimStart || 0) : (line.trimEnd || 1)
                    };

                    const onMove = (ev) => {
                        if (!draggingTrimState.value) return;
                        const state = draggingTrimState.value;
                        const line = scriptLines.value.find(l => l.id === state.lineId);
                        if (!line) return;

                        const deltaX = ev.clientX - state.startX;
                        const deltaPercent = deltaX / state.containerWidth;
                        let newVal = Math.max(0, Math.min(1, state.startVal + deltaPercent));

                        if (state.type === 'start') {
                            line.trimStart = Math.min(newVal, (line.trimEnd || 1) - 0.01);
                        } else {
                            line.trimEnd = Math.max(newVal, (line.trimStart || 0) + 0.01);
                        }
                    };

                    const onUp = () => {
                        window.removeEventListener('mousemove', onMove);
                        window.removeEventListener('mouseup', onUp);
                        draggingTrimState.value = null;
                        triggerAutoSave(); // ä¿å­˜å‰ªè¾‘ç»“æœ
                    };

                    window.addEventListener('mousemove', onMove);
                    window.addEventListener('mouseup', onUp);
                };

                // Watchers for Auto-Save
                watch([rawScript, characters, sfxLibrary, bgmLibrary, timbres, filterLibrary, emotionPresets], () => {
                    triggerAutoSave();
                }, { deep: true });

                watch(scriptLines, () => {
                    triggerAutoSave();
                }, { deep: true });

                // è¯»å–æŒä¹…åŒ–é…ç½®
                onMounted(async () => {

                    // ä»…ä¿ç•™ LLM å’Œ TTS çš„é…ç½®æŒä¹…åŒ– (API Key ç­‰)
                    const savedList = localStorage.getItem('storyforge_configs');
                    if (savedList) {
                        llmConfigs.value = JSON.parse(savedList);
                    } else {
                        // è¿ç§»æ—§æ•°æ®æˆ–åˆå§‹åŒ–é»˜è®¤
                        const oldSingle = localStorage.getItem('storyforge_universal_v2');
                        if (oldSingle) {
                            const c = JSON.parse(oldSingle);
                            llmConfigs.value.push({ ...c, id: Date.now().toString(), name: 'é»˜è®¤é…ç½®' });
                            localStorage.removeItem('storyforge_universal_v2');
                        }
                    }

                    const savedLlmId = localStorage.getItem('unitale_llmConfigId');
                    if (savedLlmId && llmConfigs.value.some(c => c.id === savedLlmId)) {
                        currentConfigId.value = savedLlmId;
                    } else if (llmConfigs.value.length > 0) {
                        currentConfigId.value = llmConfigs.value[0].id;
                    }

                    // è¯»å– TTS é…ç½®
                    const savedTts = localStorage.getItem('storyforge_tts_configs');
                    if (savedTts) ttsConfigs.value = JSON.parse(savedTts);

                    const savedTtsId = localStorage.getItem('unitale_ttsConfigId');
                    if (savedTtsId && ttsConfigs.value.some(c => c.id === savedTtsId)) {
                        currentTtsConfigId.value = savedTtsId;
                    } else if (ttsConfigs.value.length > 0) {
                        currentTtsConfigId.value = ttsConfigs.value[0].id;
                    }

                    // åˆå§‹åŒ–é»˜è®¤æ»¤æ³¢å™¨
                    filterLibrary.value = [
                        { id: 'f1', name: 'ç”µè¯éŸ³', description: 'æ¨¡æ‹Ÿç”µè¯é€šè¯æ—¶çš„çª„é¢‘å¸¦å£°éŸ³', type: 'bandpass', frequency: 1700, Q: 1.5, gain: 0, enabled: true },
                        { id: 'f2', name: 'æ°´ä¸‹', description: 'æ¨¡æ‹Ÿåœ¨æ°´ä¸‹å¬åˆ°çš„é—·å£°', type: 'lowpass', frequency: 400, Q: 1, gain: 0, enabled: true },
                        { id: 'f3', name: 'è€å¹¿æ’­', description: 'æ¨¡æ‹Ÿè€å¼æ”¶éŸ³æœºæˆ–å¹¿æ’­çš„å°–é”å£°éŸ³', type: 'highpass', frequency: 1500, Q: 1, gain: 0, enabled: true },
                        { id: 'f4', name: 'æœºæ¢°å¤±çœŸ', description: 'æ¨¡æ‹Ÿæœºå™¨äººæˆ–è®¾å¤‡æŸåæ—¶çš„å¤±çœŸå£°éŸ³', type: 'distortion', frequency: 1000, Q: 1, gain: 50, enabled: true }
                    ];

                    // åˆå§‹åŒ–é»˜è®¤æƒ…ç»ª
                    emotionPresets.value = [...SYSTEM_EMOTIONS];

                    const savedPrompt = localStorage.getItem('storyforge_prompt_template');
                    if (savedPrompt) {
                        customPromptTemplate.value = savedPrompt;
                    }

                    const savedUseCustom = localStorage.getItem('storyforge_use_custom_prompt');
                    if (savedUseCustom) {
                        useCustomPrompt.value = JSON.parse(savedUseCustom);
                    }

                    const savedVoicePrompt = localStorage.getItem('storyforge_voice_prompt_template');
                    if (savedVoicePrompt) {
                        customVoicePromptTemplate.value = savedVoicePrompt;
                    }
                    const savedUseCustomVoice = localStorage.getItem('storyforge_use_custom_voice_prompt');
                    if (savedUseCustomVoice) {
                        useCustomVoicePrompt.value = JSON.parse(savedUseCustomVoice);
                    }

                    const savedQwenText = localStorage.getItem('storyforge_qwen_voice_text_template');
                    if (savedQwenText) {
                        customQwenVoiceTextTemplate.value = savedQwenText;
                    }
                    const savedUseCustomQwen = localStorage.getItem('storyforge_use_custom_qwen_voice_text');
                    if (savedUseCustomQwen) {
                        useCustomQwenVoiceText.value = JSON.parse(savedUseCustomQwen);
                    }

                    // --- Restore from IndexedDB ---
                    try {
                        if (!dbInstance) await initDB();

                        // 1. Load Project Data
                        const projectData = await new Promise((resolve) => {
                            const tx = dbInstance.transaction('project', 'readonly');
                            const req = tx.objectStore('project').get('currentState');
                            req.onsuccess = () => resolve(req.result);
                            req.onerror = () => resolve(null);
                        });

                        if (projectData) {
                            rawScript.value = projectData.rawScript || '';
                            rawAnalysisResult.value = projectData.rawAnalysisResult || '';
                            characters.value = projectData.characters || [];

                            if (projectData.libraries) {
                                sfxLibrary.value = projectData.libraries.sfx || [];
                                bgmLibrary.value = projectData.libraries.bgm || [];
                                timbres.value = projectData.libraries.timbres || [];
                                filterLibrary.value = projectData.libraries.filters || [];
                                if (projectData.libraries.emotions && Array.isArray(projectData.libraries.emotions)) {
                                    // æ¢å¤æƒ…ç»ªåº“ï¼šä¿ç•™è‡ªå®šä¹‰æƒ…ç»ª + æ¢å¤ç³»ç»Ÿæƒ…ç»ªçš„å¯ç”¨çŠ¶æ€
                                    const customLoaded = projectData.libraries.emotions.filter(e => !isSystemEmotion(e.name) && Array.isArray(e.vector));
                                    const systemLoaded = projectData.libraries.emotions.filter(e => isSystemEmotion(e.name));

                                    const mergedSystem = SYSTEM_EMOTIONS.map(def => {
                                        const saved = systemLoaded.find(s => s.name === def.name);
                                        return { ...def, enabled: saved ? saved.enabled : undefined };
                                    });

                                    emotionPresets.value = [...mergedSystem, ...customLoaded];
                                } else {
                                    emotionPresets.value = [...SYSTEM_EMOTIONS];
                                }
                            }

                            // 2. Restore Assets & Audio
                            const restoreAssets = async (lib, fileKey) => {
                                for (const item of lib) {
                                    const filename = item[fileKey];
                                    if (filename) {
                                        // ä¼˜åŒ–ï¼šå¦‚æœå†…å­˜ä¸­å·²å­˜åœ¨ï¼Œè·³è¿‡é‡å¤åŠ è½½
                                        if (localFileMap.value.has(filename)) continue;

                                        const blob = await loadAssetFromDB(filename);
                                        if (blob) {
                                            const file = new File([blob], filename, { type: blob.type });
                                            localFileMap.value.set(filename, file);
                                            loadAudioBuffer(filename);
                                        }
                                    }
                                }
                            };
                            await restoreAssets(sfxLibrary.value, 'filename');
                            await restoreAssets(bgmLibrary.value, 'filename');
                            await restoreAssets(timbres.value, 'refPath');
                            // ä¿®å¤ Bugï¼šç¡®ä¿åŠ è½½è§’è‰²å½“å‰ç»‘å®šçš„éŸ³è‰²æ–‡ä»¶ï¼ˆå³ä½¿å®ƒå·²è¢«éŸ³è‰²åº“æ›´æ–°è¦†ç›–ï¼Œå±äºâ€œæ—§ç‰ˆâ€æ–‡ä»¶ï¼Œä¹Ÿéœ€è¦åŠ è½½ä»¥ä¾¿è¯¥è§’è‰²ä½¿ç”¨ï¼‰
                            await restoreAssets(characters.value, 'voiceFile');

                            // 3. Restore Script Lines
                            const restoredLines = [];
                            for (const lineData of projectData.scriptLines) {
                                // ç¡®ä¿ trimStart/trimEnd å­˜åœ¨
                                const line = { trimStart: 0, trimEnd: 1, ...lineData, audioUrl: '', isGenerating: false };

                                if (line.type === 'dialogue') {
                                    const audioKey = `line_audio_${line.id}`;
                                    const blob = await loadAssetFromDB(audioKey);
                                    if (blob) {
                                        line.audioUrl = URL.createObjectURL(blob);
                                    }
                                }
                                restoredLines.push(line);
                            }
                            scriptLines.value = restoredLines;
                            console.log('Project state restored from IndexedDB');
                        }
                    } catch (e) {
                        console.error('Failed to restore from IndexedDB', e);
                    }
                });

                const currentTtsConfig = computed(() => {
                    return ttsConfigs.value.find(c => c.id === currentTtsConfigId.value) || null;
                });

                // --- é…ç½®ç®¡ç†é€»è¾‘ ---
                const saveConfigsToLocal = () => {
                    localStorage.setItem('storyforge_configs', JSON.stringify(llmConfigs.value));
                };

                const saveConfig = () => {
                    if (!form.value.name || !form.value.baseUrl || !form.value.key) {
                        return alert('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯');
                    }

                    form.value.baseUrl = form.value.baseUrl.trim();
                    form.value.key = form.value.key.trim();

                    if (isEditing.value) {
                        const index = llmConfigs.value.findIndex(c => c.id === form.value.id);
                        if (index !== -1) llmConfigs.value[index] = { ...form.value };
                    } else {
                        llmConfigs.value.push({ ...form.value, id: Date.now().toString() });
                    }

                    saveConfigsToLocal();
                    resetForm();

                    // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªï¼Œè‡ªåŠ¨é€‰ä¸­
                    if (llmConfigs.value.length === 1) {
                        currentConfigId.value = llmConfigs.value[0].id;
                    }
                };

                const editConfig = (conf) => {
                    form.value = { ...conf };
                    isEditing.value = true;
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                };

                const deleteConfig = (id) => {
                    if (!confirm('ç¡®å®šåˆ é™¤æ­¤é…ç½®å—ï¼Ÿ')) return;
                    llmConfigs.value = llmConfigs.value.filter(c => c.id !== id);
                    saveConfigsToLocal();
                    if (currentConfigId.value === id) currentConfigId.value = '';
                };

                const resetForm = () => {
                    form.value = { id: '', name: '', baseUrl: '', model: '', key: '', params: '' };
                    isEditing.value = false;
                };

                // --- TTS é…ç½®ç®¡ç†é€»è¾‘ ---
                const saveTtsConfigsToLocal = () => {
                    localStorage.setItem('storyforge_tts_configs', JSON.stringify(ttsConfigs.value));
                };

                const saveTtsConfig = () => {
                    if (!ttsForm.value.name || !ttsForm.value.baseUrl) {
                        return alert('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯');
                    }

                    ttsForm.value.baseUrl = ttsForm.value.baseUrl.trim();

                    if (isEditingTts.value) {
                        const index = ttsConfigs.value.findIndex(c => c.id === ttsForm.value.id);
                        if (index !== -1) ttsConfigs.value[index] = { ...ttsForm.value };
                    } else {
                        ttsConfigs.value.push({ ...ttsForm.value, id: Date.now().toString() });
                    }

                    saveTtsConfigsToLocal();
                    resetTtsForm();
                };

                const editTtsConfig = (conf) => {
                    ttsForm.value = { ...conf };
                    isEditingTts.value = true;
                };

                const deleteTtsConfig = (id) => {
                    if (!confirm('ç¡®å®šåˆ é™¤æ­¤ TTS é…ç½®å—ï¼Ÿ')) return;
                    ttsConfigs.value = ttsConfigs.value.filter(c => c.id !== id);
                    saveTtsConfigsToLocal();
                };

                const resetTtsForm = () => {
                    ttsForm.value = { id: '', name: '', baseUrl: '' };
                    isEditingTts.value = false;
                };

                // --- è§’è‰²åº“ç®¡ç†é€»è¾‘ (å·¦ä¾§æ ) ---
                const addCharacter = () => {
                    characters.value.push({
                        id: Date.now().toString(),
                        name: 'æ–°è§’è‰²',
                        voiceFile: '' // Path for both display and synthesis
                    });
                };

                const deleteCharacter = (id) => {
                    if (!confirm('ç¡®å®šåˆ é™¤æ­¤è§’è‰²å—ï¼Ÿ')) return;
                    characters.value = characters.value.filter(c => c.id !== id);
                };

                const analyzeCharacterVoice = async (char) => {
                    if (char.isAnalyzing) {
                        if (char.abortController) char.abortController.abort();
                        return;
                    }

                    if (!currentConfig.value) return alert('è¯·å…ˆåœ¨â€œæ¨¡å‹é…ç½®â€ä¸­é…ç½® LLM');
                    if (!rawScript.value.trim()) return alert('è¯·å…ˆåœ¨å³ä¾§è¾“å…¥å°è¯´åŸæ–‡');

                    char.isAnalyzing = true;
                    const controller = new AbortController();
                    char.abortController = controller;

                    try {
                        const templateToUse = useCustomVoicePrompt.value ? customVoicePromptTemplate.value : defaultVoicePromptTemplate;
                        const promptText = templateToUse
                            .replace(/\${charName}/g, char.name)
                            .replace(/\${rawScript}/g, rawScript.value.substring(0, 3000));

                        const cfg = currentConfig.value;
                        let url = cfg.baseUrl.trim().replace(/\/+$/, '');
                        if (!url.endsWith('/chat/completions')) url += '/chat/completions';

                        let body = { model: cfg.model, messages: [{ role: 'user', content: promptText }], stream: false };
                        if (cfg.params) {
                            try { body = { ...body, ...JSON.parse(cfg.params) }; } catch (e) { }
                        }

                        const res = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${cfg.key}` },
                            body: JSON.stringify(body),
                            signal: controller.signal
                        });

                        if (!res.ok) throw new Error(`LLM è¯·æ±‚å¤±è´¥: ${res.status}`);
                        const data = await res.json();
                        const content = data.choices[0]?.message?.content || '';
                        char.voiceDescription = content.trim();
                    } catch (e) {
                        if (e.name !== 'AbortError') {
                            alert('åˆ†æå¤±è´¥: ' + e.message);
                        }
                    } finally {
                        char.isAnalyzing = false;
                        delete char.abortController;
                    }
                };

                const generateQwenVoice = async (char) => {
                    if (char.isGeneratingVoice) {
                        if (char.abortController) char.abortController.abort();
                        return;
                    }

                    if (!currentTtsConfig.value) return alert('è¯·å…ˆé€‰æ‹© TTS æœåŠ¡');
                    if (!char.voiceDescription) return alert('è¯·å…ˆå¡«å†™éŸ³è‰²æè¿°');

                    char.isGeneratingVoice = true;
                    const startTime = Date.now();
                    const controller = new AbortController();
                    char.abortController = controller;

                    // è®¾ç½® 30 åˆ†é’Ÿ (1800ç§’) çš„å‰ç«¯è¶…æ—¶æ—¶é—´ï¼Œé˜²æ­¢å‰ç«¯ä»£ç ä¸»åŠ¨æ”¾å¼ƒ
                    const timeoutId = setTimeout(() => {
                        if (char.abortController) char.abortController.abort("timeout");
                    }, 1800000);

                    try {
                        const cfg = currentTtsConfig.value;
                        let baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');
                        if (baseUrl.endsWith('/v1')) baseUrl = baseUrl.slice(0, -3);

                        const template = useCustomQwenVoiceText.value ? customQwenVoiceTextTemplate.value : defaultQwenVoiceTextTemplate;
                        const textToUse = template.replace(/\${charName}/g, char.name).replace(/\${char\.name}/g, char.name);

                        const payload = {
                            voice_description: char.voiceDescription,
                            text: textToUse
                        };

                        // 1. è°ƒç”¨ Qwen3 ç”ŸæˆéŸ³é¢‘
                        const genRes = await fetch(`${baseUrl}/v1/qwen/design`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                            signal: controller.signal,
                            cache: 'no-store'
                        });

                        // Don't clear timeout here, as upload might still need it
                        // clearTimeout(timeoutId); 

                        if (!genRes.ok) {
                            const err = await genRes.text();
                            throw new Error(`ç”Ÿæˆå¤±è´¥: ${err}`);
                        }

                        const blob = await genRes.blob();
                        const filename = `qwen_${char.name}_${Date.now()}.wav`;
                        const file = new File([blob], filename, { type: 'audio/wav' });

                        // 2. ä¿å­˜åˆ°æœ¬åœ°èµ„æºç®¡ç†
                        localFileMap.value.set(filename, file);
                        await saveAssetToDB(filename, file);

                        // 3. ä¸Šä¼ å› TTS æœåŠ¡å™¨ (ç”¨äº IndexTTS è°ƒç”¨)
                        const formData = new FormData();
                        formData.append('audio', file);
                        formData.append('full_path', filename);

                        const upRes = await fetch(`${baseUrl}/v1/upload_audio`, {
                            method: 'POST',
                            body: formData,
                            signal: controller.signal
                        });
                        if (!upRes.ok) throw new Error('ä¸Šä¼ å‚è€ƒéŸ³é¢‘å¤±è´¥');

                        // 4. æ·»åŠ æˆ–æ›´æ–°éŸ³è‰²åº“
                        const timbreName = `${char.name}_AI`;
                        const existingIndex = timbres.value.findIndex(t => t.name === timbreName);

                        if (existingIndex !== -1) {
                            // æ›´æ–°å·²æœ‰éŸ³è‰²
                            timbres.value[existingIndex].description = char.voiceDescription;
                            timbres.value[existingIndex].refPath = filename;
                        } else {
                            // æ–°å¢éŸ³è‰²
                            timbres.value.push({
                                id: Date.now().toString(),
                                name: timbreName,
                                description: char.voiceDescription,
                                refPath: filename
                            });
                        }

                        // 5. é€‰ä¸­è¯¥éŸ³è‰²
                        char.voiceFile = filename;

                        // 6. è‡ªåŠ¨ä¿å­˜
                        triggerAutoSave();

                    } catch (e) {
                        console.error(e);
                        let msg = e.message;
                        const duration = (Date.now() - startTime) / 1000;

                        if (e.name === 'AbortError') {
                            if (controller.signal.reason === "timeout") {
                                msg = 'è¯·æ±‚è¶…æ—¶ (è¶…è¿‡ 30 åˆ†é’Ÿ)ã€‚è¯·æ£€æŸ¥åç«¯æ˜¯å¦å¡æ­»ã€‚';
                            } else {
                                msg = 'æ“ä½œå·²æ‰‹åŠ¨å–æ¶ˆã€‚';
                            }
                        } else if (msg === 'Failed to fetch') {
                            msg = `è¿æ¥å¼‚å¸¸ä¸­æ–­ (è€—æ—¶ ${Math.round(duration)}ç§’)ã€‚\nè¿™ä¸æ˜¯å‰ç«¯ä»£ç è®¾å®šçš„è¶…æ—¶(30åˆ†é’Ÿ)ï¼Œè€Œæ˜¯æ‚¨çš„æµè§ˆå™¨æˆ–ç½‘ç»œç¯å¢ƒ(å¦‚ä»£ç†/Nginx)å¼ºåˆ¶æ–­å¼€äº†è¿æ¥ã€‚\n\nç”±äºæ— æ³•ä¿®æ”¹åç«¯ä¿å­˜æ–‡ä»¶ï¼Œæ­¤éŸ³é¢‘å·²ä¸¢å¤±ã€‚\nå»ºè®®ï¼šå°è¯•ç²¾ç®€éŸ³è‰²æè¿°ä»¥å‡å°‘ç”Ÿæˆæ—¶é—´ã€‚`;
                        }
                        alert('ç”ŸæˆéŸ³è‰²å¤±è´¥: ' + msg);
                    } finally {
                        clearTimeout(timeoutId);
                        char.isGeneratingVoice = false;
                        delete char.abortController;
                    }
                };


                const generateMossVoice = async (char) => {
                    if (char.isGeneratingMossVoice) {
                        if (char.mossAbortController) char.mossAbortController.abort();
                        return;
                    }

                    if (!currentTtsConfig.value) return alert('è¯·å…ˆé€‰æ‹© TTS æœåŠ¡');
                    if (!char.voiceDescription) return alert('è¯·å…ˆå¡«å†™éŸ³è‰²æè¿°');

                    char.isGeneratingMossVoice = true;
                    const startTime = Date.now();
                    const controller = new AbortController();
                    char.mossAbortController = controller;

                    const timeoutId = setTimeout(() => {
                        if (char.mossAbortController) char.mossAbortController.abort("timeout");
                    }, 1800000);

                    try {
                        const cfg = currentTtsConfig.value;
                        let baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');
                        if (baseUrl.endsWith('/v1')) baseUrl = baseUrl.slice(0, -3);

                        const template = useCustomQwenVoiceText.value ? customQwenVoiceTextTemplate.value : defaultQwenVoiceTextTemplate;
                        const textToUse = template.replace(/\${charName}/g, char.name).replace(/\${char\.name}/g, char.name);

                        const payload = {
                            voice_description: char.voiceDescription,
                            text: textToUse
                        };

                        // 1. è°ƒç”¨ MOSS VoiceGenerator ç”ŸæˆéŸ³é¢‘
                        const genRes = await fetch(`${baseUrl}/v1/moss/design`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                            signal: controller.signal,
                            cache: 'no-store'
                        });

                        if (!genRes.ok) {
                            const err = await genRes.text();
                            throw new Error(`ç”Ÿæˆå¤±è´¥: ${err}`);
                        }

                        const blob = await genRes.blob();
                        const filename = `moss_${char.name}_${Date.now()}.wav`;
                        const file = new File([blob], filename, { type: 'audio/wav' });

                        // 2. ä¿å­˜åˆ°æœ¬åœ°èµ„æºç®¡ç†
                        localFileMap.value.set(filename, file);
                        await saveAssetToDB(filename, file);

                        // 3. ä¸Šä¼ å› TTS æœåŠ¡å™¨ (ç”¨äº IndexTTS è°ƒç”¨)
                        const formData = new FormData();
                        formData.append('audio', file);
                        formData.append('full_path', filename);

                        const upRes = await fetch(`${baseUrl}/v1/upload_audio`, {
                            method: 'POST',
                            body: formData,
                            signal: controller.signal
                        });
                        if (!upRes.ok) throw new Error('ä¸Šä¼ å‚è€ƒéŸ³é¢‘å¤±è´¥');

                        // 4. æ·»åŠ æˆ–æ›´æ–°éŸ³è‰²åº“
                        const timbreName = `${char.name}_MOSS`;
                        const existingIndex = timbres.value.findIndex(t => t.name === timbreName);

                        if (existingIndex !== -1) {
                            timbres.value[existingIndex].description = char.voiceDescription;
                            timbres.value[existingIndex].refPath = filename;
                        } else {
                            timbres.value.push({
                                id: Date.now().toString(),
                                name: timbreName,
                                description: char.voiceDescription,
                                refPath: filename
                            });
                        }

                        // 5. é€‰ä¸­è¯¥éŸ³è‰²
                        char.voiceFile = filename;

                        // 6. è‡ªåŠ¨ä¿å­˜
                        triggerAutoSave();

                    } catch (e) {
                        console.error(e);
                        let msg = e.message;
                        const duration = (Date.now() - startTime) / 1000;

                        if (e.name === 'AbortError') {
                            if (controller.signal.reason === "timeout") {
                                msg = 'è¯·æ±‚è¶…æ—¶ (è¶…è¿‡ 30 åˆ†é’Ÿ)ã€‚è¯·æ£€æŸ¥åç«¯æ˜¯å¦å¡æ­»ã€‚';
                            } else {
                                msg = 'æ“ä½œå·²æ‰‹åŠ¨å–æ¶ˆã€‚';
                            }
                        } else if (msg === 'Failed to fetch') {
                            msg = `è¿æ¥å¼‚å¸¸ä¸­æ–­ (è€—æ—¶ ${Math.round(duration)}ç§’)ã€‚`;
                        }
                        alert('MOSS ç”ŸæˆéŸ³è‰²å¤±è´¥: ' + msg);
                    } finally {
                        clearTimeout(timeoutId);
                        char.isGeneratingMossVoice = false;
                        delete char.mossAbortController;
                    }
                };

                const generateSfxWithMoss = async () => {
                    if (!currentTtsConfig.value) return alert('è¯·å…ˆé€‰æ‹© TTS æœåŠ¡');
                    if (!sfxGenForm.value.description) return alert('è¯·è¾“å…¥éŸ³æ•ˆæè¿°');
                    if (!sfxGenForm.value.name) return alert('è¯·è¾“å…¥éŸ³æ•ˆåç§°');

                    isGeneratingSfx.value = true;
                    try {
                        const cfg = currentTtsConfig.value;
                        let baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');
                        if (baseUrl.endsWith('/v1')) baseUrl = baseUrl.slice(0, -3);

                        // 1. è°ƒç”¨åç«¯ç”ŸæˆéŸ³æ•ˆ
                        const res = await fetch(`${baseUrl}/v1/moss/sfx`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                ambient_sound: sfxGenForm.value.description,
                                duration_seconds: sfxGenForm.value.duration
                            })
                        });
                        if (!res.ok) throw new Error(await res.text());

                        // 2. ä¿å­˜åˆ°æœ¬åœ°
                        const blob = await res.blob();
                        const filename = `moss_sfx_${sfxGenForm.value.name}_${Date.now()}.wav`;
                        const file = new File([blob], filename, { type: 'audio/wav' });
                        localFileMap.value.set(filename, file);
                        await saveAssetToDB(filename, file);

                        // 3. è‡ªåŠ¨æ·»åŠ åˆ°éŸ³æ•ˆåº“
                        sfxLibrary.value.push({
                            id: Date.now().toString(),
                            name: sfxGenForm.value.name,
                            description: sfxGenForm.value.description,
                            filename: filename,
                            enabled: true
                        });

                        // 4. é¢„åŠ è½½ AudioBuffer
                        loadAudioBuffer(filename);
                        triggerAutoSave();
                        alert('éŸ³æ•ˆç”ŸæˆæˆåŠŸï¼å·²æ·»åŠ åˆ°éŸ³æ•ˆåº“ã€‚');
                        sfxGenForm.value = { description: '', duration: 5, name: '' };
                    } catch (e) {
                        alert('éŸ³æ•ˆç”Ÿæˆå¤±è´¥: ' + e.message);
                    } finally {
                        isGeneratingSfx.value = false;
                    }
                };

                const generateMissingSfx = async (sfx, line) => {
                    if (!currentTtsConfig.value) return alert('è¯·å…ˆé€‰æ‹© TTS æœåŠ¡');
                    if (!sfx.name) return alert('ç¼ºå°‘éŸ³æ•ˆæè¿°/åç§°');

                    sfx._isGeneratingSfx = true;
                    try {
                        const cfg = currentTtsConfig.value;
                        let baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');
                        if (baseUrl.endsWith('/v1')) baseUrl = baseUrl.slice(0, -3);

                        // 1. è°ƒç”¨åç«¯ç”ŸæˆéŸ³æ•ˆï¼Œä½¿ç”¨å…¶ name ä½œä¸º description
                        const res = await fetch(`${baseUrl}/v1/moss/sfx`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                ambient_sound: sfx.name,
                                duration_seconds: 3 // Default brief duration for inline SFX
                            })
                        });
                        if (!res.ok) throw new Error(await res.text());

                        const blob = await res.blob();
                        const filename = `moss_sfx_${Date.now()}_${Math.random().toString(36).substr(2, 5)}.wav`;
                        const file = new File([blob], filename, { type: 'audio/wav' });
                        localFileMap.value.set(filename, file);
                        await saveAssetToDB(filename, file);

                        // 2. è‡ªåŠ¨æ·»åŠ åˆ°éŸ³æ•ˆåº“
                        const newId = Date.now().toString();
                        sfxLibrary.value.push({
                            id: newId,
                            name: sfx.name,
                            description: `(AI è‡ªåŠ¨è¡¥å…¨) ${sfx.name}`,
                            filename: filename,
                            enabled: true
                        });

                        loadAudioBuffer(filename);
                        triggerAutoSave();
                    } catch (e) {
                        alert('éŸ³æ•ˆç”Ÿæˆå¤±è´¥: ' + e.message);
                    } finally {
                        sfx._isGeneratingSfx = false;
                    }
                };

                // --- å½•éŸ³ä¸ä¸Šä¼ å‚è€ƒéŸ³é¢‘é€»è¾‘ ---
                const openVoiceRecordModal = (char) => {
                    recordTargetChar.value = char;
                    isRecordModalOpen.value = true;
                    recordState.value = 'idle';
                    recordAudioBuffer.value = null;
                    recordTrimStart.value = 0;
                    recordTrimEnd.value = 1;
                    stopTrimmedRecord();
                };

                const closeRecordModal = () => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                    stopTrimmedRecord();
                    isRecordModalOpen.value = false;
                    recordTargetChar.value = null;
                    recordAudioBuffer.value = null;
                };

                const handleUploadVoice = async (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const decodedData = await audioContext.decodeAudioData(arrayBuffer);
                        recordAudioBuffer.value = decodedData;
                        recordState.value = 'recorded';
                        recordTrimStart.value = 0;
                        recordTrimEnd.value = 1;
                        setTimeout(drawRecordWaveform, 50);
                    } catch (err) {
                        alert('è¯»å–éŸ³é¢‘æ–‡ä»¶å¤±è´¥: ' + err.message);
                    }
                    event.target.value = '';
                };

                const startRecording = async () => {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        mediaRecorder = new MediaRecorder(stream);
                        audioChunks = [];

                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) audioChunks.push(event.data);
                        };

                        mediaRecorder.onstop = async () => {
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            stream.getTracks().forEach(track => track.stop());
                            try {
                                const arrayBuffer = await audioBlob.arrayBuffer();
                                const decodedData = await audioContext.decodeAudioData(arrayBuffer);
                                recordAudioBuffer.value = decodedData;
                                recordState.value = 'recorded';
                                recordTrimStart.value = 0;
                                recordTrimEnd.value = 1;
                                setTimeout(drawRecordWaveform, 50);
                            } catch (e) {
                                alert("å½•éŸ³å¤„ç†å¤±è´¥");
                            }
                        };

                        mediaRecorder.start();
                        recordState.value = 'recording';
                        recordAudioBuffer.value = null;
                    } catch (err) {
                        alert('æ— æ³•è®¿é—®éº¦å…‹é£: ' + err.message);
                    }
                };

                const stopRecording = () => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                };

                const drawRecordWaveform = () => {
                    const canvas = recordWaveformCanvas.value;
                    if (!canvas || !recordAudioBuffer.value) return;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    const channelData = recordAudioBuffer.value.getChannelData(0);
                    const step = Math.ceil(channelData.length / canvas.width);
                    const amp = canvas.height / 2;

                    ctx.fillStyle = '#64748b'; // slate-500
                    ctx.beginPath();
                    for (let i = 0; i < canvas.width; i++) {
                        let min = 1.0;
                        let max = -1.0;
                        for (let j = 0; j < step; j++) {
                            const datum = channelData[i * step + j];
                            if (datum < min) min = datum;
                            if (datum > max) max = datum;
                        }
                        ctx.rect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
                    }
                    ctx.fill();
                };

                const playTrimmedRecord = () => {
                    stopTrimmedRecord();
                    if (!recordAudioBuffer.value) return;

                    recordPreviewSource = audioContext.createBufferSource();
                    recordPreviewSource.buffer = recordAudioBuffer.value;
                    recordPreviewSource.connect(audioContext.destination);

                    const duration = recordAudioBuffer.value.duration;
                    const startOffset = duration * recordTrimStart.value;
                    const playDuration = duration * (recordTrimEnd.value - recordTrimStart.value);

                    recordPreviewSource.start(0, startOffset, playDuration);
                };

                const stopTrimmedRecord = () => {
                    if (recordPreviewSource) {
                        try { recordPreviewSource.stop(); } catch (e) { }
                        recordPreviewSource = null;
                    }
                };

                const saveRecordAndTrim = async () => {
                    if (!currentTtsConfig.value) return alert('è¯·å…ˆé€‰æ‹© TTS æœåŠ¡ä»¥ä¾›ä¸Šä¼ å¼•ç”¨');
                    if (!recordAudioBuffer.value) return;

                    isSavingRecord.value = true;
                    try {
                        const originalBuffer = recordAudioBuffer.value;
                        const duration = originalBuffer.duration;
                        const startOffset = duration * recordTrimStart.value;
                        const playDuration = duration * (recordTrimEnd.value - recordTrimStart.value);

                        // 1. Slice audio using OfflineAudioContext
                        const offlineCtx = new OfflineAudioContext(
                            originalBuffer.numberOfChannels,
                            Math.ceil(playDuration * originalBuffer.sampleRate),
                            originalBuffer.sampleRate
                        );

                        const source = offlineCtx.createBufferSource();
                        source.buffer = originalBuffer;
                        source.connect(offlineCtx.destination);
                        source.start(0, startOffset, playDuration);

                        const renderedBuffer = await offlineCtx.startRendering();

                        // 2. Convert to Blob
                        const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
                        const filename = `custom_${recordTargetChar.value.name}_${Date.now()}.wav`;
                        const file = new File([wavBlob], filename, { type: 'audio/wav' });

                        // 3. Save to Local
                        localFileMap.value.set(filename, file);
                        await saveAssetToDB(filename, file);

                        // 4. Upload to API
                        const cfg = currentTtsConfig.value;
                        let baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');
                        if (baseUrl.endsWith('/v1')) baseUrl = baseUrl.slice(0, -3);

                        const formData = new FormData();
                        formData.append('audio', file);
                        formData.append('full_path', filename);

                        const upRes = await fetch(`${baseUrl}/v1/upload_audio`, {
                            method: 'POST',
                            body: formData
                        });
                        if (!upRes.ok) throw new Error('ä¸Šä¼ å½•éŸ³éŸ³é¢‘å¤±è´¥');

                        // 5. Update Timbre Library and Character
                        const timbreName = `${recordTargetChar.value.name}_è‡ªé€‰å½•éŸ³`;
                        const existingIndex = timbres.value.findIndex(t => t.name === timbreName);

                        if (existingIndex !== -1) {
                            timbres.value[existingIndex].refPath = filename;
                            timbres.value[existingIndex].description = 'ç”¨æˆ·ä¸Šä¼ æˆ–å½•éŸ³çš„éŸ³è‰²';
                        } else {
                            timbres.value.push({
                                id: Date.now().toString(),
                                name: timbreName,
                                description: 'ç”¨æˆ·ä¸Šä¼ æˆ–å½•éŸ³çš„éŸ³è‰²',
                                refPath: filename
                            });
                        }

                        recordTargetChar.value.voiceFile = filename;
                        triggerAutoSave();
                        closeRecordModal();
                        alert('å·²æˆåŠŸè®¾ç½®ä¸ºè§’è‰²å‚è€ƒéŸ³é¢‘ï¼');

                    } catch (e) {
                        alert('ä¿å­˜å¤±è´¥: ' + e.message);
                        console.error(e);
                    } finally {
                        isSavingRecord.value = false;
                    }
                };

                const handleTimbreFileUpload = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        timbreForm.value.refPath = file.name;
                        timbreFile.value = file; // Store the file object
                        localFileMap.value.set(file.name, file);
                        saveAssetToDB(file.name, file); // Save to DB
                        triggerAutoSave();
                    }
                    event.target.value = ''; // Reset file input
                };

                // --- éŸ³è‰²åº“ç®¡ç†é€»è¾‘ ---
                const syncTimbresWithServer = async () => {
                    // å°è¯•è·å–å¯ç”¨çš„ TTS é…ç½®
                    let cfg = currentTtsConfig.value;
                    if (!cfg && ttsConfigs.value.length > 0) {
                        // å¦‚æœå½“å‰æœªé€‰ä¸­ï¼Œé»˜è®¤ä½¿ç”¨ç¬¬ä¸€ä¸ª
                        currentTtsConfigId.value = ttsConfigs.value[0].id;
                        cfg = ttsConfigs.value[0];
                    }

                    if (!cfg) {
                        console.warn("æœªæ‰¾åˆ°å¯ç”¨çš„ TTS é…ç½®ï¼Œæ— æ³•åŒæ­¥éŸ³è‰²æ–‡ä»¶ã€‚");
                        return;
                    }

                    let baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');
                    if (baseUrl.endsWith('/v1')) baseUrl = baseUrl.slice(0, -3);
                    console.log(`æ­£åœ¨åŒæ­¥éŸ³è‰²æ–‡ä»¶åˆ°æœåŠ¡å™¨: ${baseUrl}`);

                    for (const t of timbres.value) {
                        if (!t.refPath) continue;

                        // æ£€æŸ¥å†…å­˜ä¸­æ˜¯å¦æœ‰è¯¥æ–‡ä»¶
                        const file = localFileMap.value.get(t.refPath);
                        if (!file) {
                            console.warn(`éŸ³è‰²æ–‡ä»¶æœªåœ¨å†…å­˜ä¸­æ‰¾åˆ° (å¯èƒ½æœªå¯¼å…¥æˆ–ä¸¢å¤±): ${t.refPath}`);
                            continue;
                        }

                        try {
                            // 1. æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦å­˜åœ¨
                            const checkUrl = `${baseUrl}/v1/check/audio?file_name=${encodeURIComponent(t.refPath)}`;
                            const checkRes = await fetch(checkUrl);
                            let exists = false;
                            if (checkRes.ok) {
                                const checkData = await checkRes.json();
                                exists = checkData.exists;
                            }

                            // 2. å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™ä¸Šä¼ 
                            if (!exists) {
                                console.log(`æ­£åœ¨ä¸Šä¼ ç¼ºå¤±çš„éŸ³è‰²æ–‡ä»¶: ${t.name} (${t.refPath})`);
                                const formData = new FormData();
                                formData.append('audio', file);
                                formData.append('full_path', t.refPath);

                                await fetch(`${baseUrl}/v1/upload_audio`, {
                                    method: 'POST',
                                    body: formData,
                                });
                            } else {
                                console.log(`éŸ³è‰²æ–‡ä»¶å·²å­˜åœ¨: ${t.name}`);
                            }
                        } catch (e) {
                            console.error(`åŒæ­¥éŸ³è‰² ${t.name} å¤±è´¥:`, e);
                        }
                    }
                    console.log("éŸ³è‰²åŒæ­¥å®Œæˆã€‚");
                };

                const saveTimbre = async () => {
                    if (!timbreForm.value.name || !timbreForm.value.refPath) {
                        return alert('è¯·å¡«å†™éŸ³è‰²åç§°å¹¶é€‰æ‹©ä¸€ä¸ªå‚è€ƒéŸ³é¢‘æ–‡ä»¶');
                    }
                    if (!currentTtsConfig.value) {
                        return alert('è¯·é€‰æ‹©ä¸€ä¸ªæœ‰æ•ˆçš„ TTS æœåŠ¡ä»¥ä¸Šä¼ éŸ³é¢‘ã€‚');
                    }

                    // A file MUST be selected when creating a NEW timbre.
                    if (!isEditingTimbre.value && !timbreFile.value) {
                        return alert('åˆ›å»ºæ–°éŸ³è‰²æ—¶ï¼Œå¿…é¡»é€‰æ‹©ä¸€ä¸ªå‚è€ƒéŸ³é¢‘æ–‡ä»¶ã€‚');
                    }

                    const filename = timbreForm.value.refPath;
                    const serverPath = filename;

                    // ç¡®å®š ID (å¦‚æœæ˜¯æ–°å»ºï¼Œæå‰ç”Ÿæˆ ID ä»¥ä¾¿ä¿å­˜æ–‡ä»¶åˆ°æœ¬åœ°å­˜å‚¨)
                    let targetId = timbreForm.value.id;
                    if (!targetId) {
                        targetId = Date.now().toString();
                    }

                    try {
                        // We only perform an upload if a file was actually selected via the file input.
                        if (timbreFile.value) {
                            const cfg = currentTtsConfig.value;
                            let baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');
                            if (baseUrl.endsWith('/v1')) baseUrl = baseUrl.slice(0, -3);

                            const formData = new FormData();
                            formData.append('audio', timbreFile.value, filename);
                            formData.append('full_path', serverPath);

                            const uploadRes = await fetch(`${baseUrl}/v1/upload_audio`, {
                                method: 'POST',
                                body: formData,
                            });

                            if (!uploadRes.ok) {
                                const errorText = await uploadRes.text();
                                throw new Error(`ä¸Šä¼ å‚è€ƒéŸ³é¢‘åˆ° TTS æœåŠ¡å™¨å¤±è´¥: ${errorText}`);
                            }
                            console.log(`éŸ³è‰²æ–‡ä»¶ '${filename}' å·²æˆåŠŸä¸Šä¼ åˆ° TTS æœåŠ¡å™¨ã€‚`);
                        }

                        const newTimbreData = { ...timbreForm.value, id: targetId };

                        // After a potential upload, save the metadata.
                        if (isEditingTimbre.value) {
                            const index = timbres.value.findIndex(c => c.id === targetId);
                            if (index !== -1) {
                                timbres.value[index] = newTimbreData;
                            }
                        } else {
                            timbres.value.push(newTimbreData);
                        }
                        // saveTimbresToLocal(); // ä¸å†æŒä¹…åŒ–åˆ° localStorage
                        resetTimbreForm();

                    } catch (e) {
                        console.error("ä¿å­˜éŸ³è‰²æ—¶å‡ºé”™:", e);
                        alert(`ä¿å­˜éŸ³è‰²å¤±è´¥: ${e.message}`);
                    }
                };

                const editTimbre = (timbre) => {
                    timbreForm.value = { ...timbre };
                    isEditingTimbre.value = true;
                    timbreFile.value = null; // Important: reset file on edit start
                };

                const deleteTimbre = async (id) => {
                    if (!confirm('ç¡®å®šåˆ é™¤æ­¤éŸ³è‰²å—ï¼Ÿ')) return;
                    timbres.value = timbres.value.filter(c => c.id !== id);
                    // saveTimbresToLocal();
                    if (selectedTimbreId.value === id) selectedTimbreId.value = '';
                };

                const resetTimbreForm = () => {
                    timbreForm.value = { id: '', name: '', description: '', refPath: '' };
                    isEditingTimbre.value = false;
                    timbreFile.value = null; // Reset the stored file
                };

                // --- éŸ³æ•ˆåº“ç®¡ç†é€»è¾‘ ---
                // ç§»é™¤ saveSfxToLocal

                const saveSfx = async () => {
                    if (!sfxForm.value.name || !sfxForm.value.filename) {
                        return alert('è¯·å¡«å†™éŸ³æ•ˆåç§°å’Œæ–‡ä»¶è·¯å¾„');
                    }

                    try {
                        if (isEditingSfx.value) {
                            const index = sfxLibrary.value.findIndex(s => s.id === sfxForm.value.id);
                            if (index !== -1) sfxLibrary.value[index] = { ...sfxForm.value };
                        } else {
                            sfxLibrary.value.push({ ...sfxForm.value, id: Date.now().toString(), enabled: true });
                        }
                        if (sfxForm.value.filename) loadAudioBuffer(sfxForm.value.filename);
                        // saveSfxToLocal();
                        resetSfxForm();
                    } catch (e) {
                        alert(`ä¿å­˜éŸ³æ•ˆå¤±è´¥: ${e.message}`);
                    }
                };

                const editSfx = (sfx) => {
                    sfxForm.value = { ...sfx };
                    isEditingSfx.value = true;
                };

                const deleteSfx = (id) => {
                    if (!confirm('ç¡®å®šåˆ é™¤ï¼Ÿ')) return;
                    sfxLibrary.value = sfxLibrary.value.filter(s => s.id !== id);
                    // saveSfxToLocal();
                };

                const resetSfxForm = () => {
                    sfxForm.value = { id: '', name: '', description: '', filename: '' };
                    isEditingSfx.value = false;
                };

                const handleSfxFileUpload = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        sfxForm.value.filename = file.name;
                        localFileMap.value.set(file.name, file);
                        saveAssetToDB(file.name, file); // Save to DB
                        triggerAutoSave();
                        loadAudioBuffer(file.name);
                    }
                    event.target.value = '';
                };

                // --- BGMåº“ç®¡ç†é€»è¾‘ ---
                const saveBgmToLocal = () => {
                    localStorage.setItem('storyforge_bgm', JSON.stringify(bgmLibrary.value));
                };

                const saveBgm = async () => {
                    if (!bgmForm.value.name || !bgmForm.value.filename) {
                        return alert('è¯·å¡«å†™ BGM åç§°å’Œæ–‡ä»¶è·¯å¾„');
                    }

                    try {
                        if (isEditingBgm.value) {
                            const index = bgmLibrary.value.findIndex(s => s.id === bgmForm.value.id);
                            if (index !== -1) bgmLibrary.value[index] = { ...bgmForm.value };
                        } else {
                            bgmLibrary.value.push({ ...bgmForm.value, id: Date.now().toString(), enabled: true });
                        }
                        if (bgmForm.value.filename) loadAudioBuffer(bgmForm.value.filename);
                        // saveBgmToLocal();
                        resetBgmForm();
                    } catch (e) {
                        alert(`ä¿å­˜ BGM å¤±è´¥: ${e.message}`);
                    }
                };

                const editBgm = (bgm) => {
                    bgmForm.value = { ...bgm };
                    isEditingBgm.value = true;
                };

                const deleteBgm = (id) => {
                    if (!confirm('ç¡®å®šåˆ é™¤ï¼Ÿ')) return;
                    bgmLibrary.value = bgmLibrary.value.filter(s => s.id !== id);
                    // saveBgmToLocal();
                };

                const resetBgmForm = () => {
                    bgmForm.value = { id: '', name: '', description: '', filename: '' };
                    isEditingBgm.value = false;
                };

                const handleBgmFileUpload = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        bgmForm.value.filename = file.name;
                        localFileMap.value.set(file.name, file);
                        saveAssetToDB(file.name, file); // Save to DB
                        triggerAutoSave();
                        loadAudioBuffer(file.name);
                    }
                    event.target.value = '';
                };

                // --- æ»¤æ³¢å™¨åº“ç®¡ç†é€»è¾‘ ---
                const saveFiltersToLocal = () => {
                    localStorage.setItem('storyforge_filters', JSON.stringify(filterLibrary.value));
                };

                const saveFilter = () => {
                    if (!filterForm.value.name) return alert('è¯·å¡«å†™æ»¤æ³¢å™¨åç§°');

                    const newFilter = { ...filterForm.value };
                    // Ensure numbers
                    newFilter.frequency = Number(newFilter.frequency);
                    newFilter.Q = Number(newFilter.Q);
                    newFilter.gain = Number(newFilter.gain);

                    if (isEditingFilter.value) {
                        const index = filterLibrary.value.findIndex(f => f.id === filterForm.value.id);
                        if (index !== -1) filterLibrary.value[index] = newFilter;
                    } else {
                        filterLibrary.value.push({ ...newFilter, id: Date.now().toString(), enabled: true });
                    }
                    // saveFiltersToLocal();
                    resetFilterForm();
                };

                const editFilter = (filter) => {
                    filterForm.value = { ...filter };
                    isEditingFilter.value = true;
                };

                const deleteFilter = (id) => {
                    if (!confirm('ç¡®å®šåˆ é™¤æ­¤æ»¤æ³¢å™¨ï¼Ÿ')) return;
                    filterLibrary.value = filterLibrary.value.filter(f => f.id !== id);
                    // saveFiltersToLocal();
                };

                const resetFilterForm = () => {
                    filterForm.value = { id: '', name: '', description: '', type: 'lowpass', frequency: 1000, Q: 1, gain: 0 };
                    isEditingFilter.value = false;
                };

                // --- æƒ…ç»ªé¢„è®¾ç®¡ç†é€»è¾‘ ---
                // ç§»é™¤ saveEmotionPresetsToLocal

                const saveEmotion = () => {
                    if (!emotionForm.value.name) return alert('è¯·å¡«å†™æƒ…ç»ªåç§°');
                    if (isSystemEmotion(emotionForm.value.name)) return alert('æ— æ³•ä¿®æ”¹æˆ–è¦†ç›–ç³»ç»Ÿé¢„è®¾æƒ…ç»ª');
                    if (isEditingEmotion.value) {
                        const index = emotionPresets.value.findIndex(e => e.id === emotionForm.value.id);
                        if (index !== -1) emotionPresets.value[index] = { ...emotionForm.value };
                    } else {
                        emotionPresets.value.push({ ...emotionForm.value, id: Date.now().toString(), enabled: true });
                    }
                    // saveEmotionPresetsToLocal();
                    resetEmotionForm();
                };

                const editEmotion = (emo) => {
                    emotionForm.value = { ...emo };
                    isEditingEmotion.value = true;
                };

                const deleteEmotion = (id) => {
                    if (!confirm('ç¡®å®šåˆ é™¤ï¼Ÿ')) return;
                    emotionPresets.value = emotionPresets.value.filter(e => e.id !== id);
                    // saveEmotionPresetsToLocal();
                };

                const resetEmotionForm = () => {
                    emotionForm.value = { id: '', name: '', vector: [0, 0, 0, 0, 0, 0, 0, 0] };
                    isEditingEmotion.value = false;
                };

                const resetEmotionsToDefault = () => {
                    if (!confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰æƒ…ç»ªé¢„è®¾ä¸ºé»˜è®¤å€¼å—ï¼Ÿè¿™å°†æ¸…é™¤è‡ªå®šä¹‰çš„æƒ…ç»ªã€‚')) return;
                    emotionPresets.value = [...SYSTEM_EMOTIONS];
                    // saveEmotionPresetsToLocal();
                };

                const availableRoles = computed(() => {
                    const roles = new Set(characters.value.map(c => c.name));
                    return Array.from(roles);
                });

                // --- æ‹–æ‹½ä¸æ’åºé€»è¾‘ ---
                const draggingIndex = ref(-1);
                const moveLineUp = (index) => {
                    if (index <= 0) return;
                    const item = scriptLines.value.splice(index, 1)[0];
                    scriptLines.value.splice(index - 1, 0, item);
                };
                const moveLineDown = (index) => {
                    if (index >= scriptLines.value.length - 1) return;
                    const item = scriptLines.value.splice(index, 1)[0];
                    scriptLines.value.splice(index + 1, 0, item);
                };

                const toggleLineSelection = (index, event) => {
                    if (event) {
                        // å¦‚æœç‚¹å‡»çš„æ˜¯äº¤äº’å¼æ§ä»¶ï¼ˆè¾“å…¥æ¡†ã€æŒ‰é’®ã€ä¸‹æ‹‰æ¡†ç­‰ï¼‰æˆ–å…¶å†…éƒ¨å…ƒç´ ï¼Œåˆ™ä¸åˆ‡æ¢é€‰ä¸­çŠ¶æ€
                        const interactive = event.target.closest('input, select, textarea, button, label, a');
                        if (interactive) return;
                    }
                    if (selectedLineIndex.value === index) {
                        selectedLineIndex.value = -1;
                    } else {
                        selectedLineIndex.value = index;
                    }
                };

                let dialogueSource = null;
                let sfxSources = [];
                const isAuditioningId = ref(null);

                // Helper for distortion
                const makeDistortionCurve = (amount) => {
                    const k = typeof amount === 'number' ? amount : 50;
                    const n_samples = 44100;
                    const curve = new Float32Array(n_samples);
                    const deg = Math.PI / 180;
                    for (let i = 0; i < n_samples; ++i) {
                        const x = (i * 2) / n_samples - 1;
                        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
                    }
                    return curve;
                };

                const intensityMap = {
                    "å¾®å¼±": 0.2,
                    "ç¨å¼±": 0.35,
                    "ä¸­ç­‰": 0.5,
                    "è¾ƒå¼º": 0.75,
                    "å¼ºçƒˆ": 1.0
                };

                const generateLineAudio = async (line, externalSignal = null) => {
                    // This button is a toggle. If the line is already generating, this aborts it.
                    if (line.isGenerating) {
                        if (line.abortController) {
                            line.abortController.abort();
                        }
                        return; // The finally block of the original call will handle cleanup.
                    }

                    if (!currentTtsConfig.value) {
                        alert('è¯·å…ˆåœ¨ TTS é…ç½®ä¸­å¿ƒé€‰æ‹©ä¸€ä¸ª TTS æœåŠ¡');
                        return;
                    }

                    line.isGenerating = true;
                    const controller = new AbortController();
                    line.abortController = controller;
                    const internalSignal = controller.signal;

                    // Link external signal if provided (for batch abort)
                    const handleExternalAbort = () => controller.abort();
                    externalSignal?.addEventListener('abort', handleExternalAbort);

                    try {
                        const char = characters.value.find(c => c.name === line.role);
                        if (!char || !char.voiceFile) {
                            throw new Error(`è§’è‰² "${line.role}" æœªç»‘å®šéŸ³è‰²æ–‡ä»¶è·¯å¾„ã€‚\n\nè¯·åœ¨å·¦ä¾§çš„è§’è‰²åˆ—è¡¨ä¸­ä¸ºè¯¥è§’è‰²é€‰æ‹©ä¸€ä¸ªéŸ³è‰²æ–‡ä»¶ï¼Œæˆ–æ‰‹åŠ¨è¾“å…¥è·¯å¾„ã€‚`);
                        }

                        let finalVector = [0, 0, 0, 0, 0, 0, 0, 0];
                        const preset = emotionPresets.value.find(e => e.name === line.emotion);
                        if (preset && preset.vector) {
                            if (isSystemEmotion(line.emotion)) {
                                const intensityVal = intensityMap[line.intensity] || 0.5;
                                finalVector = preset.vector.map(v => v * intensityVal);
                            } else {
                                finalVector = preset.vector;
                            }
                        }

                        const payload = {
                            text: line.text,
                            audio_path: char.voiceFile,
                            emo_vector: finalVector
                        };

                        const cfg = currentTtsConfig.value;
                        let baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');
                        if (baseUrl.endsWith('/v1')) baseUrl = baseUrl.slice(0, -3);

                        const voiceFile = localFileMap.value.get(char.voiceFile);
                        if (voiceFile) {
                            try {
                                const checkUrl = `${baseUrl}/v1/check/audio?file_name=${encodeURIComponent(char.voiceFile)}`;
                                const checkRes = await fetch(checkUrl, { signal: internalSignal });
                                let exists = false;
                                if (checkRes.ok) {
                                    exists = (await checkRes.json()).exists;
                                }
                                if (!exists) {
                                    const formData = new FormData();
                                    formData.append('audio', voiceFile, char.voiceFile);
                                    formData.append('full_path', char.voiceFile);
                                    await fetch(`${baseUrl}/v1/upload_audio`, { method: 'POST', body: formData, signal: internalSignal });
                                }
                            } catch (e) {
                                if (e.name !== 'AbortError') console.warn('è‡ªåŠ¨ä¸Šä¼ éŸ³è‰²æ–‡ä»¶å¤±è´¥:', e);
                                else throw e; // Propagate abort
                            }
                        }

                        const synthRes = await fetch(`${baseUrl}/v2/synthesize`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                            signal: internalSignal
                        });

                        if (!synthRes.ok) {
                            const errText = await synthRes.text();
                            throw new Error(`è¯­éŸ³åˆæˆå¤±è´¥: ${errText}`);
                        }

                        const blob = await synthRes.blob();
                        await saveAssetToDB(`line_audio_${line.id}`, blob);
                        const audioUrl = URL.createObjectURL(blob);
                        line.audioUrl = audioUrl;
                        line.trimStart = 0;
                        line.trimEnd = 1;

                    } catch (e) {
                        // Don't show alert for abort errors, just log and re-throw
                        if (e.name !== 'AbortError') {
                            alert(e.message);
                            console.error(e);
                        }
                        throw e; // Re-throw so the caller (e.g., generateAllLines) knows about the failure.
                    } finally {
                        line.isGenerating = false;
                        delete line.abortController;
                        externalSignal?.removeEventListener('abort', handleExternalAbort);
                    }
                };

                let batchAbortController = null;

                const generateAllLines = async () => {

                    if (isGeneratingAll.value) {

                        if (batchAbortController) {

                            batchAbortController.abort();

                        }

                        return;

                    }



                    const startIndex = selectedLineIndex.value !== -1 ? selectedLineIndex.value : 0;

                    const linesToCheck = scriptLines.value.slice(startIndex);



                    // Pre-flight check on lines that will be processed

                    const linesToProcess = linesToCheck.filter(l => l.type === 'dialogue' && !l.audioUrl);

                    for (const line of linesToProcess) {

                        const char = characters.value.find(c => c.name === line.role);

                        if (!char || !char.voiceFile) {

                            const lineIndex = scriptLines.value.findIndex(l => l.id === line.id);

                            alert(`ä¸€é”®ç”Ÿæˆå·²ç»ˆæ­¢ã€‚\n\nåŸå› ï¼šç¬¬ ${lineIndex + 1} è¡Œå°è¯çš„è§’è‰²ï¼ˆ${line.role}ï¼‰æ²¡æœ‰ç»‘å®šéŸ³æºã€‚`);

                            return;

                        }

                    }



                    const dialogueCount = linesToProcess.length;

                    if (dialogueCount === 0) {

                        alert('æ²¡æœ‰éœ€è¦ç”Ÿæˆçš„å°è¯éŸ³é¢‘ã€‚');

                        return;

                    }



                    const confirmMsg = startIndex > 0

                        ? `å³å°†ä»ç¬¬ ${startIndex + 1} è¡Œï¼ˆé€‰ä¸­è¡Œï¼‰å¼€å§‹ï¼Œä¸ºåç»­ ${dialogueCount} æ¡ã€æœªç”Ÿæˆã€‘çš„å°è¯ç”ŸæˆéŸ³é¢‘ã€‚ç¡®å®šç»§ç»­å—ï¼Ÿ`

                        : `å³å°†ä¸ºå…¨éƒ¨ ${dialogueCount} æ¡ã€æœªç”Ÿæˆã€‘çš„å°è¯ç”ŸæˆéŸ³é¢‘ã€‚ç¡®å®šç»§ç»­å—ï¼Ÿ`;



                    if (!confirm(confirmMsg)) return;



                    isGeneratingAll.value = true;

                    batchAbortController = new AbortController();

                    const batchSignal = batchAbortController.signal;

                    let failedCount = 0;



                    try {

                        // Iterate through the original slice to maintain order, but only process what's needed.

                        for (const line of linesToCheck) {

                            if (batchSignal.aborted) break;



                            if (line.type === 'dialogue' && !line.audioUrl) {

                                try {

                                    await generateLineAudio(line, batchSignal);

                                } catch (e) {

                                    if (e.name !== 'AbortError') {

                                        console.error(`Error generating line for role ${line.role}:`, e);

                                        failedCount++;

                                    }

                                }

                            }

                        }



                        if (batchSignal.aborted) {

                            alert('æ‰¹é‡ç”Ÿæˆå·²åœæ­¢ã€‚');

                        } else if (failedCount > 0) {

                            alert(`ä¸€é”®ç”Ÿæˆå®Œæˆï¼Œä½†æœ‰ ${failedCount} æ¡å°è¯ç”Ÿæˆå¤±è´¥ã€‚è¯·æ£€æŸ¥æ§åˆ¶å°æˆ–å•ç‹¬é‡æ–°ç”Ÿæˆå¤±è´¥çš„å°è¯ã€‚`);

                        } else {

                            await saveProjectToDB();

                            alert('æ‰¹é‡ç”Ÿæˆå®Œæˆï¼');

                        }

                    } catch (e) {

                        console.error("ç”Ÿæˆå…¨éƒ¨éŸ³é¢‘æ—¶å‘ç”Ÿæ„å¤–é”™è¯¯:", e);

                        alert('ç”Ÿæˆè¿‡ç¨‹ä¸­å‡ºç°æœªçŸ¥é”™è¯¯ï¼Œè¯¦æƒ…è¯·æŸ¥çœ‹æ§åˆ¶å°ã€‚');

                    } finally {

                        isGeneratingAll.value = false;

                        batchAbortController = null;

                    }

                };



                const clearAllGeneratedAudio = async () => {

                    const linesWithAudio = scriptLines.value.filter(l => l.audioUrl);

                    if (linesWithAudio.length === 0) {

                        return alert('æ²¡æœ‰å·²ç”Ÿæˆçš„éŸ³é¢‘å¯ä»¥æ¸…é™¤ã€‚');

                    }

                    if (!confirm(`ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰ ${linesWithAudio.length} æ¡å·²ç”Ÿæˆçš„éŸ³é¢‘å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {

                        return;

                    }



                    for (const line of linesWithAudio) {

                        // Don't wait for each one, do them in parallel

                        clearLineAudio(line);

                    }



                    alert('æ‰€æœ‰å·²ç”Ÿæˆçš„éŸ³é¢‘å·²è¢«æ¸…é™¤ã€‚');

                };

                const playLineAudio = (line, stopPreviousSfx = true) => {
                    return new Promise(async (resolve, reject) => {
                        try {
                            // 1. Resume AudioContext if it's suspended
                            if (audioContext.state === 'suspended') {
                                await audioContext.resume();
                            }

                            // 2. Stop anything currently playing
                            if (dialogueSource) {
                                dialogueSource.onended = null; // Prevent onended from firing on manual stop
                                dialogueSource.stop();
                                dialogueSource = null;
                            }

                            if (playbackAnimationFrame) {
                                cancelAnimationFrame(playbackAnimationFrame);
                                playbackAnimationFrame = null;
                            }

                            if (stopPreviousSfx) {
                                sfxSources.forEach(source => { try { source.stop(); } catch (e) { } });
                                sfxSources = [];
                            }

                            // If it was a stop request (clicking the same line in manual mode)
                            if (isAuditioningId.value === line.id) {
                                isAuditioningId.value = null;
                                return resolve();
                            }

                            if (!line.audioUrl) return resolve(); // Resolve silently if no audio

                            isAuditioningId.value = line.id;

                            // 3. Prepare loading promises (Parallel loading)
                            const loadDialogue = async () => {
                                const res = await fetch(line.audioUrl);
                                const ab = await res.arrayBuffer();
                                return await audioContext.decodeAudioData(ab);
                            };

                            const loadSfx = async () => {
                                if (!line.sfx || line.sfx.length === 0) return [];
                                const promises = line.sfx.map(async (sfxItem) => {
                                    const sfxLibItem = sfxLibrary.value.find(s => s.name === sfxItem.name);
                                    if (sfxLibItem && sfxLibItem.filename) {
                                        const buf = await loadAudioBuffer(sfxLibItem.filename);
                                        if (buf) return { buffer: buf, item: sfxItem };
                                    }
                                    return null;
                                });
                                const results = await Promise.all(promises);
                                return results.filter(r => r !== null);
                            };

                            // 4. Execute loads in parallel
                            const [dialogueBuffer, sfxBuffers] = await Promise.all([
                                loadDialogue(),
                                loadSfx()
                            ]);

                            // 5. Set up dialogue
                            dialogueSource = audioContext.createBufferSource();
                            dialogueSource.buffer = dialogueBuffer;

                            // è®¡ç®—å‰ªè¾‘å‚æ•°
                            const trimStart = line.trimStart || 0;
                            const trimEnd = line.trimEnd || 1;
                            const duration = dialogueBuffer.duration;
                            const startTimeOffset = duration * trimStart;
                            const playDuration = duration * (trimEnd - trimStart);
                            const speed = line.speed || 1.0;

                            const dialogueGain = audioContext.createGain();
                            dialogueGain.gain.setValueAtTime(line.dialogueVolume ?? 1.0, audioContext.currentTime);

                            // --- Filter Logic ---
                            let lastNode = dialogueSource;

                            if (line.filter) {
                                const filterConfig = filterLibrary.value.find(f => f.name === line.filter);
                                if (filterConfig) {
                                    if (filterConfig.type === 'distortion') {
                                        const waveShaper = audioContext.createWaveShaper();
                                        waveShaper.curve = makeDistortionCurve(filterConfig.gain);
                                        waveShaper.oversample = '4x';
                                        lastNode.connect(waveShaper);
                                        lastNode = waveShaper;
                                    } else {
                                        const biquad = audioContext.createBiquadFilter();
                                        biquad.type = filterConfig.type;
                                        biquad.frequency.value = filterConfig.frequency;
                                        biquad.Q.value = filterConfig.Q;
                                        lastNode.connect(biquad);
                                        lastNode = biquad;
                                    }
                                }
                            }

                            // Connect to gain then destination
                            lastNode.connect(dialogueGain).connect(audioContext.destination);
                            dialogueSource.playbackRate.value = speed;

                            const now = audioContext.currentTime + 0.05; // Slight delay for sync

                            // 6. Schedule SFX
                            sfxBuffers.forEach(({ buffer, item }) => {
                                const originalDuration = dialogueBuffer.duration;
                                const absStart = originalDuration * trimStart;
                                const absEnd = originalDuration * trimEnd;
                                const pos = parseFloat(item.position) || 0;
                                const absSfxTime = originalDuration * pos;

                                if (absSfxTime >= absStart && absSfxTime <= absEnd) {
                                    const sSrc = audioContext.createBufferSource();
                                    sSrc.buffer = buffer;
                                    const sGain = audioContext.createGain();
                                    // ä½¿ç”¨æ¯ä¸ªéŸ³æ•ˆç‹¬ç«‹çš„éŸ³é‡ï¼Œå›é€€åˆ°å°è¯çº§åˆ« sfxVolume
                                    const sfxVol = item.volume !== undefined ? parseFloat(item.volume) : (line.sfxVolume ?? 0.5);
                                    sGain.gain.setValueAtTime(sfxVol, now);
                                    sSrc.connect(sGain).connect(audioContext.destination);

                                    // éŸ³æ•ˆè‡ªèº«çš„è£å‰ªå‚æ•°
                                    const sfxTrimStart = parseFloat(item.trimStart) || 0;
                                    const sfxTrimEnd = parseFloat(item.trimEnd) || 1;
                                    const sfxOffset = buffer.duration * sfxTrimStart;
                                    const sfxPlayDuration = buffer.duration * (sfxTrimEnd - sfxTrimStart);

                                    const relativeStart = absSfxTime - absStart;
                                    sSrc.start(now + relativeStart / speed, sfxOffset, sfxPlayDuration);

                                    sfxSources.push(sSrc);
                                    sSrc.onended = () => {
                                        const idx = sfxSources.indexOf(sSrc);
                                        if (idx > -1) sfxSources.splice(idx, 1);
                                    };
                                }
                            });

                            // 7. Play dialogue
                            dialogueSource.onended = async () => {
                                // This event fires on natural end or manual .stop()
                                if (playbackAnimationFrame) {
                                    cancelAnimationFrame(playbackAnimationFrame);
                                    playbackAnimationFrame = null;
                                }
                                if (isAuditioningId.value === line.id) {
                                    isAuditioningId.value = null;
                                }
                                resolve();
                            };

                            dialogueSource.start(now, startTimeOffset, playDuration);

                            // å¯åŠ¨è¿›åº¦æ¡åŠ¨ç”»
                            const updateProgress = () => {
                                if (isAuditioningId.value !== line.id) return;
                                const elapsed = audioContext.currentTime - now;
                                if (elapsed >= 0) {
                                    // è®¡ç®—å½“å‰åœ¨æ•´ä¸ªæ–‡ä»¶ä¸­çš„ç™¾åˆ†æ¯”ä½ç½®
                                    // å½“å‰ä½ç½® = (startTimeOffset + elapsed) / totalDuration
                                    // startTimeOffset = duration * trimStart
                                    // => (duration * trimStart + elapsed) / duration
                                    // => trimStart + (elapsed / duration)
                                    const progress = trimStart + (elapsed * speed / duration);
                                    playbackProgress.value = Math.min(progress, trimEnd);
                                } else {
                                    playbackProgress.value = trimStart;
                                }

                                if (audioContext.currentTime < now + (playDuration / speed)) {
                                    playbackAnimationFrame = requestAnimationFrame(updateProgress);
                                } else {
                                    playbackProgress.value = trimEnd;
                                }
                            };
                            playbackAnimationFrame = requestAnimationFrame(updateProgress);

                        } catch (e) {
                            console.error("Failed to play audio:", e);
                            // alert('æ’­æ”¾éŸ³é¢‘å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æˆ–ç½‘ç»œã€‚'); // Suppress alert for smoother UX
                            isAuditioningId.value = null;
                            resolve(); // Resolve to not block sequence
                        }
                    });
                };

                const clearLineAudio = async (line) => {
                    if (!line.audioUrl) return;

                    const audioUrlToDelete = line.audioUrl;
                    const audioKey = `line_audio_${line.id}`;

                    line.audioUrl = '';
                    URL.revokeObjectURL(audioUrlToDelete);

                    if (audioBufferCache.has(audioUrlToDelete)) {
                        audioBufferCache.delete(audioUrlToDelete);
                    }

                    try {
                        if (!dbInstance) await initDB();
                        await new Promise((resolve, reject) => {
                            const tx = dbInstance.transaction('assets', 'readwrite');
                            const store = tx.objectStore('assets');
                            const req = store.delete(audioKey);
                            req.onsuccess = () => resolve();
                            req.onerror = (e) => reject(e.target.error);
                        });
                    } catch (e) {
                        console.error(`Failed to delete asset ${audioKey} from DB`, e);
                    }

                    triggerAutoSave();
                };

                // --- å­˜æ¡£ç®¡ç†é€»è¾‘ ---
                const blobToBase64 = (blob) => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                };

                const base64ToBlob = (base64, mimeType) => {
                    const byteString = atob(base64.split(',')[1]);
                    const ab = new ArrayBuffer(byteString.length);
                    const ia = new Uint8Array(ab);
                    for (let i = 0; i < byteString.length; i++) {
                        ia[i] = byteString.charCodeAt(i);
                    }
                    return new Blob([ab], { type: mimeType });
                };

                const exportScriptState = async () => {
                    if (!confirm('å³å°†å¯¼å‡ºåŒ…å«æ‰€æœ‰ç´ æï¼ˆéŸ³æ•ˆã€BGMã€éŸ³è‰²ï¼‰çš„å®Œæ•´å·¥ç¨‹æ–‡ä»¶ã€‚å¦‚æœç´ æè¾ƒå¤šï¼Œæ–‡ä»¶å¯èƒ½è¾ƒå¤§ï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚')) return;

                    isExportingProject.value = true;
                    exportStatus.value = 'å‡†å¤‡ä¸­...';

                    try {
                        // 1. å¤„ç†èµ„æºåº“ (åµŒå…¥éŸ³é¢‘æ–‡ä»¶)
                        const processLibrary = async (lib, fileKey) => {
                            const processed = [];
                            for (let i = 0; i < lib.length; i++) {
                                const item = lib[i];
                                // è¿›åº¦æç¤º & è®©å‡ºä¸»çº¿ç¨‹é˜²æ­¢å¡æ­»
                                if (i % 5 === 0) {
                                    exportStatus.value = `æ‰“åŒ…èµ„æº ${i}/${lib.length}`;
                                    await new Promise(r => setTimeout(r, 0));
                                }

                                const itemCopy = { ...item };
                                const filename = item[fileKey];
                                if (filename) {
                                    let blob = null;
                                    // 1. ä¼˜å…ˆä»å†…å­˜ Map è·å– (File å¯¹è±¡)
                                    if (localFileMap.value.has(filename)) {
                                        blob = localFileMap.value.get(filename);
                                    }
                                    // 2. å¦‚æœå†…å­˜æ²¡æœ‰ï¼Œå°è¯•ä» IndexedDB è¯»å– (Blob)
                                    if (!blob) {
                                        blob = await loadAssetFromDB(filename);
                                    }

                                    if (blob) {
                                        try {
                                            itemCopy._fileData = await blobToBase64(blob);
                                            itemCopy._mimeType = blob.type;
                                        } catch (e) {
                                            console.warn(`Failed to embed file: ${filename}`, e);
                                        }
                                    }
                                }
                                processed.push(itemCopy);
                            }
                            return processed;
                        };

                        const sfxExport = await processLibrary(sfxLibrary.value, 'filename');
                        const bgmExport = await processLibrary(bgmLibrary.value, 'filename');
                        const timbreExport = await processLibrary(timbres.value, 'refPath');

                        // å°†éŸ³é¢‘è½¬æ¢ä¸º Base64 ä»¥ä¾¿ä¿å­˜
                        const linesToSave = [];
                        const totalLines = scriptLines.value.length;

                        for (let i = 0; i < totalLines; i++) {
                            const line = scriptLines.value[i];

                            if (i % 5 === 0) {
                                exportStatus.value = `æ‰“åŒ…å°è¯ ${i}/${totalLines}`;
                                await new Promise(r => setTimeout(r, 0));
                            }

                            const lineCopy = { ...line };
                            lineCopy.isGenerating = false; // æ¸…ç†çŠ¶æ€

                            // å°è¯•è·å–éŸ³é¢‘ Blob (ä¼˜å…ˆ fetch URLï¼Œå¤±è´¥åˆ™æŸ¥ DB)
                            let blob = null;
                            if (line.audioUrl) {
                                try {
                                    const res = await fetch(line.audioUrl);
                                    blob = await res.blob();
                                } catch (e) { /* ignore */ }
                            }

                            if (!blob && line.type === 'dialogue') {
                                blob = await loadAssetFromDB(`line_audio_${line.id}`);
                            }

                            if (blob) {
                                try {
                                    lineCopy.audioBase64 = await blobToBase64(blob);
                                    lineCopy.audioUrl = ''; // å¯¼å‡ºæ—¶ä¸ä¿å­˜ blob URL
                                } catch (e) {
                                    console.warn('å¯¼å‡ºéŸ³é¢‘å¤±è´¥:', line.id, e);
                                }
                            }
                            linesToSave.push(lineCopy);
                        }

                        exportStatus.value = 'ç”Ÿæˆæ–‡ä»¶...';
                        await new Promise(r => setTimeout(r, 50)); // ç»™ UI ä¸€ç‚¹æ—¶é—´åˆ·æ–°

                        const data = {
                            version: '2.0',
                            timestamp: new Date().toISOString(),
                            // èµ„æºåº“
                            libraries: {
                                sfx: sfxExport,
                                bgm: bgmExport,
                                timbres: timbreExport,
                                filters: filterLibrary.value,
                                emotions: emotionPresets.value
                            },
                            // é¡¹ç›®çŠ¶æ€
                            project: {
                                rawScript: rawScript.value,
                                rawAnalysisResult: rawAnalysisResult.value,
                                characters: characters.value,
                                scriptLines: linesToSave
                            }
                        };
                        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const now = new Date();
                        const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
                        a.download = `Unitaleå·¥ç¨‹æ–‡ä»¶_${timestamp}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        console.error(e);
                        alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
                    } finally {
                        isExportingProject.value = false;
                        exportStatus.value = '';
                    }
                };

                const triggerImport = () => {
                    importFileRef.value.click();
                };

                const handleImportFile = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            isExportingProject.value = true; // å¤ç”¨ loading çŠ¶æ€
                            exportStatus.value = 'è§£æä¸­...';

                            const data = JSON.parse(e.target.result);
                            const assetsToSave = []; // ç”¨äºæ‰¹é‡æ”¶é›†å¾…ä¿å­˜çš„éŸ³é¢‘æ–‡ä»¶

                            // è¾…åŠ©å‡½æ•°ï¼šæ¢å¤èµ„æºåº“æ–‡ä»¶
                            const restoreLibraryFiles = async (libItems, fileKey) => {
                                if (!libItems) return [];
                                const restoredItems = [];
                                for (const item of libItems) {
                                    if (item._fileData) {
                                        try {
                                            const blob = base64ToBlob(item._fileData, item._mimeType || 'audio/wav');
                                            const file = new File([blob], item[fileKey], { type: item._mimeType || 'audio/wav' });
                                            localFileMap.value.set(item[fileKey], file);

                                            // ä¼˜åŒ–ï¼šæ”¶é›†åˆ°æ‰¹é‡åˆ—è¡¨ï¼Œç¨åç»Ÿä¸€ä¿å­˜
                                            assetsToSave.push({ key: item[fileKey], blob: file });

                                            // é¢„åŠ è½½åˆ°ç¼“å­˜
                                            loadAudioBuffer(item[fileKey]);

                                            delete item._fileData;
                                            delete item._mimeType;
                                        } catch (err) {
                                            console.warn(`Failed to restore file: ${item[fileKey]}`, err);
                                        }
                                    }
                                    restoredItems.push(item);
                                }
                                return restoredItems;
                            };

                            if (data.version === '2.0' || data.project) {
                                // v2.0 å®Œæ•´å·¥ç¨‹æ ¼å¼
                                if (!confirm('æ£€æµ‹åˆ°å®Œæ•´å·¥ç¨‹æ–‡ä»¶ã€‚å¯¼å…¥å°†è¦†ç›–å½“å‰çš„ã€èµ„æºåº“å’Œè„šæœ¬ã€‘ï¼ˆæ¨¡å‹é…ç½®ä¸ä¼šè¢«è¦†ç›–ï¼‰ã€‚ç¡®å®šç»§ç»­å—ï¼Ÿ')) return;

                                // --- æ¸…ç©ºå½“å‰æ•°æ® ---
                                rawScript.value = '';
                                rawAnalysisResult.value = '';
                                characters.value = [];
                                scriptLines.value = [];
                                sfxLibrary.value = [];
                                bgmLibrary.value = [];
                                timbres.value = [];
                                filterLibrary.value = [];
                                emotionPresets.value = [];
                                localFileMap.value.clear();
                                audioBufferCache.clear();

                                // 2. æ¢å¤èµ„æºåº“
                                if (data.libraries) {
                                    sfxLibrary.value = await restoreLibraryFiles(data.libraries.sfx, 'filename');
                                    bgmLibrary.value = await restoreLibraryFiles(data.libraries.bgm, 'filename');
                                    timbres.value = await restoreLibraryFiles(data.libraries.timbres, 'refPath');
                                    filterLibrary.value = data.libraries.filters || [];
                                    emotionPresets.value = data.libraries.emotions || [];

                                    // æ¢å¤æƒ…ç»ªåº“ï¼šåˆå¹¶ç³»ç»Ÿé¢„è®¾ + å¯¼å…¥çš„è‡ªå®šä¹‰æƒ…ç»ª
                                    if (data.libraries.emotions && Array.isArray(data.libraries.emotions)) {
                                        const customImported = data.libraries.emotions.filter(e => !isSystemEmotion(e.name) && Array.isArray(e.vector));
                                        const systemImported = data.libraries.emotions.filter(e => isSystemEmotion(e.name));

                                        const mergedSystem = SYSTEM_EMOTIONS.map(def => {
                                            const imported = systemImported.find(s => s.name === def.name);
                                            return { ...def, enabled: imported ? imported.enabled : undefined };
                                        });

                                        emotionPresets.value = [...mergedSystem, ...customImported];
                                    } else {
                                        emotionPresets.value = [...SYSTEM_EMOTIONS];
                                    }

                                    // ä¸å†è°ƒç”¨ save*ToLocalï¼Œå› ä¸ºæ•°æ®ä»…åœ¨å†…å­˜ä¸­

                                    // 4. åŒæ­¥éŸ³è‰²åˆ°æœåŠ¡å™¨
                                    try {
                                        await syncTimbresWithServer();
                                    } catch (e) {
                                        console.warn("Timbre sync failed:", e);
                                    }
                                }

                                // 3. æ¢å¤é¡¹ç›®çŠ¶æ€
                                const proj = data.project;
                                rawScript.value = proj.rawScript || '';
                                rawAnalysisResult.value = proj.rawAnalysisResult || '';
                                characters.value = proj.characters || [];

                                // æ¢å¤å°è¯éŸ³é¢‘
                                exportStatus.value = 'æ¢å¤å°è¯éŸ³é¢‘...';
                                const restoredLines = [];
                                for (let i = 0; i < proj.scriptLines.length; i++) {
                                    const line = proj.scriptLines[i];
                                    if (i % 20 === 0) exportStatus.value = `æ¢å¤å°è¯ ${i}/${proj.scriptLines.length}`;

                                    if (line.audioBase64) {
                                        try {
                                            const res = await fetch(line.audioBase64);
                                            const blob = await res.blob();

                                            // ä¼˜åŒ–ï¼šæ”¶é›†åˆ°æ‰¹é‡åˆ—è¡¨
                                            assetsToSave.push({ key: `line_audio_${line.id}`, blob: blob });

                                            if (line.speed === undefined) line.speed = 1.0; // Ensure speed exists for old saves
                                            line.audioUrl = URL.createObjectURL(blob);
                                            delete line.audioBase64; // æ¸…ç†å†…å­˜
                                        } catch (err) { console.warn('Audio restore failed', err); }
                                    }
                                    restoredLines.push(line);
                                }
                                scriptLines.value = restoredLines;

                                // æ‰§è¡Œæ‰¹é‡ä¿å­˜ (ä¸€æ¬¡æ€§å†™å…¥æ‰€æœ‰æ–‡ä»¶)
                                exportStatus.value = 'å†™å…¥æ•°æ®åº“...';
                                if (assetsToSave.length > 0) {
                                    try {
                                        await saveAssetsBatch(assetsToSave);
                                    } catch (e) {
                                        console.error("Asset save failed:", e);
                                        alert("è­¦å‘Šï¼šéƒ¨åˆ†éŸ³é¢‘èµ„æºä¿å­˜åˆ°æ•°æ®åº“å¤±è´¥ï¼ˆå¯èƒ½æ˜¯ç©ºé—´ä¸è¶³ï¼‰ï¼Œåˆ·æ–°é¡µé¢åå¯èƒ½ä¼šä¸¢å¤±éŸ³é¢‘æ–‡ä»¶ã€‚ä½†è„šæœ¬å’Œè§’è‰²è®¾ç½®å°†å°è¯•ä¿å­˜ã€‚");
                                    }
                                }

                                // å¼ºåˆ¶ä¿å­˜ä¸€æ¬¡é¡¹ç›®çŠ¶æ€åˆ° DBï¼Œç¡®ä¿ JSON æ•°æ®ä¹ŸåŒæ­¥
                                await saveProjectToDB();

                                alert('å®Œæ•´å·¥ç¨‹å¯¼å…¥æˆåŠŸï¼æ‰€æœ‰èµ„æºå’Œè®¾ç½®å·²æ¢å¤ã€‚');

                            } else if (data.scriptLines && Array.isArray(data.scriptLines)) {
                                // v1.x æ—§ç‰ˆå­˜æ¡£æ ¼å¼å…¼å®¹
                                if (confirm('æ£€æµ‹åˆ°æ—§ç‰ˆå­˜æ¡£ã€‚ç¡®å®šè¦è¯»å–å—ï¼Ÿå½“å‰æœªä¿å­˜çš„è¿›åº¦å°†è¢«è¦†ç›–ã€‚')) {
                                    // ä¿®å¤ï¼šå…ˆæ¸…ç©ºè§’è‰²åˆ—è¡¨ï¼Œé˜²æ­¢æ®‹ç•™
                                    characters.value = [];

                                    if (data.rawScript !== undefined) rawScript.value = data.rawScript;
                                    if (data.rawAnalysisResult !== undefined) rawAnalysisResult.value = data.rawAnalysisResult;

                                    // ä¿®å¤ï¼šè¯»å–å­˜æ¡£æ—¶ï¼Œå¦‚æœå­˜æ¡£åŒ…å«è§’è‰²åˆ—è¡¨åˆ™ç›´æ¥ä½¿ç”¨ï¼Œå¦åˆ™æ ¹æ®å°è¯é‡å»ºè§’è‰²åˆ—è¡¨
                                    // è¿™æ ·å¯ä»¥ç¡®ä¿â€œæ²¡æœ‰çš„è§’è‰²è¦åˆ é™¤â€ï¼Œå¹¶ä¸”â€œè§’è‰²çš„éŸ³è‰²é€‰ç”¨ä¹Ÿè¦ä¿å­˜â€
                                    if (data.characters && Array.isArray(data.characters)) {
                                        characters.value = data.characters;
                                    } else {
                                        // å…¼å®¹æ—§å­˜æ¡£ï¼šä»å°è¯ä¸­æå–è§’è‰²
                                        const roles = new Set();
                                        data.scriptLines.forEach(l => {
                                            if (l.type === 'dialogue' && l.role) roles.add(l.role);
                                        });
                                        characters.value = Array.from(roles).map(r => {
                                            const matchingTimbre = timbres.value.find(t => t.name === r);
                                            return {
                                                id: Date.now() + Math.random().toString(),
                                                name: r,
                                                voiceFile: matchingTimbre ? matchingTimbre.refPath : ''
                                            };
                                        });
                                    }

                                    // æ¢å¤éŸ³é¢‘æ•°æ® (Base64 -> Blob URL)
                                    exportStatus.value = 'æ¢å¤æ—§ç‰ˆæ•°æ®...';
                                    const restoredLines = [];
                                    for (const line of data.scriptLines) {
                                        if (line.audioBase64) {
                                            try {
                                                const res = await fetch(line.audioBase64);
                                                const blob = await res.blob();

                                                // ä¼˜åŒ–ï¼šæ”¶é›†åˆ°æ‰¹é‡åˆ—è¡¨
                                                assetsToSave.push({ key: `line_audio_${line.id}`, blob: blob });

                                                line.audioUrl = URL.createObjectURL(blob);
                                                // delete line.audioBase64; // å¯é€‰ï¼šé‡Šæ”¾å†…å­˜ï¼Œä½†ä¿ç•™åœ¨å¯¹è±¡ä¸­ä¹Ÿæ²¡å…³ç³»
                                            } catch (err) {
                                                console.warn('æ¢å¤éŸ³é¢‘å¤±è´¥:', line.id, err);
                                            }
                                        }
                                        restoredLines.push(line);
                                    }

                                    scriptLines.value = restoredLines;

                                    exportStatus.value = 'ä¿å­˜ä¸­...';
                                    if (assetsToSave.length > 0) {
                                        try {
                                            await saveAssetsBatch(assetsToSave);
                                        } catch (e) {
                                            console.error("Asset save failed:", e);
                                        }
                                    }
                                    await saveProjectToDB();
                                    alert('å­˜æ¡£è¯»å–æˆåŠŸï¼');
                                }
                            } else {
                                alert('æ— æ•ˆçš„å­˜æ¡£æ–‡ä»¶æ ¼å¼');
                            }
                        } catch (err) {
                            alert('è¯»å–å¤±è´¥: ' + err.message);
                        } finally {
                            isExportingProject.value = false;
                            exportStatus.value = '';
                        }
                        event.target.value = ''; // Reset
                    };
                    reader.readAsText(file);
                };

                const triggerImportTxt = () => {
                    importTxtRef.value.click();
                };

                const handleImportTxt = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        rawScript.value = e.target.result;
                    };
                    reader.readAsText(file);
                    event.target.value = '';
                };

                // --- å¯¼å‡ºéŸ³é¢‘é€»è¾‘ (WAV) ---
                const exportAudio = async () => {
                    const dialogueLines = scriptLines.value.filter(l => l.type === 'dialogue');
                    if (dialogueLines.length === 0) return alert('è„šæœ¬ä¸ºç©º');
                    if (dialogueLines.some(l => !l.audioUrl)) {
                        if (!confirm('éƒ¨åˆ†å°è¯å°šæœªç”ŸæˆéŸ³é¢‘ï¼Œå¯¼å‡ºæ—¶å°†è¢«è·³è¿‡ã€‚ç¡®å®šç»§ç»­å—ï¼Ÿ')) return;
                    }

                    isExportingAudio.value = true;

                    try {
                        const assets = { dialogues: {}, sfx: {}, bgm: {} };

                        // 1. åŠ è½½æ‰€æœ‰å°è¯éŸ³é¢‘
                        for (const line of dialogueLines) {
                            if (line.audioUrl) assets.dialogues[line.id] = await loadAudioBuffer(line.audioUrl);
                        }

                        // 2. åŠ è½½ç”¨åˆ°çš„éŸ³æ•ˆ
                        const usedSfxNames = new Set();
                        scriptLines.value.forEach(l => { if (l.sfx) l.sfx.forEach(s => usedSfxNames.add(s.name)); });
                        for (const name of usedSfxNames) {
                            const item = sfxLibrary.value.find(s => s.name === name);
                            if (item && item.filename) {
                                try { assets.sfx[name] = await loadAudioBuffer(item.filename); } catch (e) { }
                            }
                        }

                        // 3. åŠ è½½ç”¨åˆ°çš„ BGM
                        const usedBgmNames = new Set();
                        scriptLines.value.forEach(l => { if (l.type === 'bgm' && l.action === 'play') usedBgmNames.add(l.bgmName); });
                        for (const name of usedBgmNames) {
                            const item = bgmLibrary.value.find(b => b.name === name);
                            if (item && item.filename) {
                                try { assets.bgm[name] = await loadAudioBuffer(item.filename); } catch (e) { }
                            }
                        }

                        // 4. è®¡ç®—æ—¶é—´è½´
                        let currentTime = 0;
                        const events = [];
                        const bgmSegments = [];
                        let currentBgm = null;

                        for (const line of scriptLines.value) {
                            if (line.type === 'bgm') {
                                if (line.action === 'play') {
                                    if (currentBgm) bgmSegments.push({ ...currentBgm, end: currentTime });
                                    currentBgm = { name: line.bgmName, start: currentTime, volume: line.volume };
                                } else if (line.action === 'stop') {
                                    if (currentBgm) {
                                        bgmSegments.push({ ...currentBgm, end: currentTime });
                                        currentBgm = null;
                                    }
                                }
                            } else if (line.type === 'dialogue') {
                                const buffer = assets.dialogues[line.id];
                                if (buffer) {
                                    // è®¡ç®—å‰ªè¾‘
                                    const trimStart = line.trimStart || 0;
                                    const trimEnd = line.trimEnd || 1;
                                    const playDuration = buffer.duration * (trimEnd - trimStart);
                                    const speed = line.speed || 1.0;
                                    const effectiveDuration = playDuration / speed;

                                    // æ¨¡æ‹Ÿ playLineAudio ä¸­çš„ 0.05s è°ƒåº¦å»¶è¿Ÿï¼Œç¡®ä¿å¯¼å‡ºèŠ‚å¥ä¸å®æ—¶æ’­æ”¾ä¸€è‡´
                                    currentTime += 0.05;
                                    events.push({ type: 'dialogue', time: currentTime, buffer: buffer, line: line, trimStart, trimEnd, playDuration, speed });
                                    currentTime += effectiveDuration;
                                }
                                currentTime += (line.break_duration || 0);
                            }
                        }
                        if (currentBgm) bgmSegments.push({ ...currentBgm, end: currentTime + 2 }); // BGM å°¾éƒ¨æ·¡å‡º

                        // 5. ç¦»çº¿æ¸²æŸ“
                        const totalDuration = currentTime + 1;
                        const offlineCtx = new OfflineAudioContext(2, totalDuration * 44100, 44100);

                        // è°ƒåº¦ BGM
                        bgmSegments.forEach(seg => {
                            const buffer = assets.bgm[seg.name];
                            if (buffer) {
                                const src = offlineCtx.createBufferSource();
                                src.buffer = buffer;
                                src.loop = true;
                                const gain = offlineCtx.createGain();
                                gain.gain.setValueAtTime(0, seg.start);
                                gain.gain.linearRampToValueAtTime(seg.volume, seg.start + 2);
                                gain.gain.setValueAtTime(seg.volume, Math.max(seg.start + 2, seg.end - 2));
                                gain.gain.linearRampToValueAtTime(0, seg.end);
                                src.connect(gain).connect(offlineCtx.destination);
                                src.start(seg.start);
                                src.stop(seg.end);
                            }
                        });

                        // è°ƒåº¦å°è¯å’ŒéŸ³æ•ˆ
                        events.forEach(evt => {
                            const dSrc = offlineCtx.createBufferSource();
                            dSrc.buffer = evt.buffer;
                            dSrc.playbackRate.value = evt.speed;
                            const dGain = offlineCtx.createGain();
                            dGain.gain.value = evt.line.dialogueVolume ?? 1.0;

                            const offset = evt.buffer.duration * evt.trimStart;
                            const duration = evt.playDuration;

                            let lastNode = dSrc;
                            // åº”ç”¨æ»¤é•œ
                            if (evt.line.filter) {
                                const fConfig = filterLibrary.value.find(f => f.name === evt.line.filter);
                                if (fConfig) {
                                    if (fConfig.type === 'distortion') {
                                        const ws = offlineCtx.createWaveShaper();
                                        ws.curve = makeDistortionCurve(fConfig.gain);
                                        ws.oversample = '4x';
                                        lastNode.connect(ws);
                                        lastNode = ws;
                                    } else {
                                        const bq = offlineCtx.createBiquadFilter();
                                        bq.type = fConfig.type;
                                        bq.frequency.value = fConfig.frequency;
                                        bq.Q.value = fConfig.Q;
                                        lastNode.connect(bq);
                                        lastNode = bq;
                                    }
                                }
                            }
                            lastNode.connect(dGain).connect(offlineCtx.destination);
                            dSrc.start(evt.time, offset, duration);

                            // è°ƒåº¦éŸ³æ•ˆ
                            if (evt.line.sfx) {
                                evt.line.sfx.forEach(s => {
                                    const sBuffer = assets.sfx[s.name];
                                    if (sBuffer) {
                                        const originalDuration = evt.buffer.duration;
                                        const absStart = originalDuration * evt.trimStart;
                                        const absEnd = originalDuration * evt.trimEnd;
                                        const pos = parseFloat(s.position) || 0;
                                        const absSfxTime = originalDuration * pos;

                                        if (absSfxTime >= absStart && absSfxTime <= absEnd) {
                                            const sSrc = offlineCtx.createBufferSource();
                                            sSrc.buffer = sBuffer;
                                            const sGain = offlineCtx.createGain();
                                            // ä½¿ç”¨æ¯ä¸ªéŸ³æ•ˆç‹¬ç«‹çš„éŸ³é‡
                                            const sfxVol = s.volume !== undefined ? parseFloat(s.volume) : (evt.line.sfxVolume ?? 0.5);
                                            sGain.gain.value = sfxVol;
                                            sSrc.connect(sGain).connect(offlineCtx.destination);

                                            // éŸ³æ•ˆè‡ªèº«çš„è£å‰ªå‚æ•°
                                            const sfxTrimStart = parseFloat(s.trimStart) || 0;
                                            const sfxTrimEnd = parseFloat(s.trimEnd) || 1;
                                            const sfxOffset = sBuffer.duration * sfxTrimStart;
                                            const sfxPlayDuration = sBuffer.duration * (sfxTrimEnd - sfxTrimStart);

                                            const relativeStart = absSfxTime - absStart;
                                            sSrc.start(evt.time + relativeStart / evt.speed, sfxOffset, sfxPlayDuration);
                                        }
                                    }
                                });
                            }
                        });

                        const renderedBuffer = await offlineCtx.startRendering();
                        const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
                        const url = URL.createObjectURL(wavBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `storyforge_export_${Date.now()}.wav`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                    } catch (e) {
                        console.error(e);
                        alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
                    } finally {
                        isExportingAudio.value = false;
                    }
                };

                const exportSRT = async () => {
                    const dialogueLines = scriptLines.value.filter(l => l.type === 'dialogue');
                    if (dialogueLines.length === 0) return alert('è„šæœ¬ä¸ºç©º');

                    if (dialogueLines.some(l => !l.audioUrl)) {
                        if (!confirm('éƒ¨åˆ†å°è¯å°šæœªç”ŸæˆéŸ³é¢‘ï¼Œå¯¼å‡ºå­—å¹•æ—¶æ—¶é—´è½´å¯èƒ½ä¸å‡†ç¡®ï¼ˆå°†è·³è¿‡æœªç”ŸæˆéŸ³é¢‘çš„è¡Œï¼‰ã€‚ç¡®å®šç»§ç»­å—ï¼Ÿ')) return;
                    }

                    isExportingAudio.value = true; // å¤ç”¨ loading çŠ¶æ€

                    try {
                        // 1. åŠ è½½æ‰€æœ‰å°è¯éŸ³é¢‘ä»¥è·å–æ—¶é•¿
                        const audioMap = new Map();
                        const loadPromises = dialogueLines.map(async (line) => {
                            if (line.audioUrl) {
                                const buffer = await loadAudioBuffer(line.audioUrl);
                                if (buffer) audioMap.set(line.id, buffer);
                            }
                        });
                        await Promise.all(loadPromises);

                        let srtContent = '';
                        let currentTime = 0;
                        let counter = 1;

                        const formatTime = (seconds) => {
                            const date = new Date(0);
                            date.setMilliseconds(seconds * 1000);
                            const hh = String(Math.floor(seconds / 3600)).padStart(2, '0');
                            const mm = String(date.getUTCMinutes()).padStart(2, '0');
                            const ss = String(date.getUTCSeconds()).padStart(2, '0');
                            const ms = String(date.getUTCMilliseconds()).padStart(3, '0');
                            return `${hh}:${mm}:${ss},${ms}`;
                        };

                        // è¾…åŠ©å‡½æ•°ï¼šæ™ºèƒ½åˆ‡å‰²é•¿å­—å¹•
                        const splitLongText = (text) => {
                            if (!text) return [];

                            // 1. å»é™¤å¥æœ«çš„é€—å·å’Œå¥å· (ä¿ç•™é—®å·æ„Ÿå¹å·ç­‰)
                            let processed = text.replace(/[ï¼Œã€‚,.]\s*$/, '');

                            // 2. å¦‚æœæ–‡æœ¬è¾ƒçŸ­ï¼Œç›´æ¥è¿”å›
                            if (processed.length <= 25) return [processed];

                            // 3. ä¼˜å…ˆæŒ‰æ ‡ç‚¹ç¬¦å·åˆ‡å‰²
                            // å¥å·(ã€‚)å’Œç‚¹(.)ï¼šä½œä¸ºåˆ†éš”ç¬¦æ¶ˆè€—æ‰ (ä¸ä¿ç•™åœ¨å¥æœ«)
                            // é—®å·ã€æ„Ÿå¹å·ç­‰ï¼šä¿ç•™åœ¨ä¸Šä¸€å¥
                            // é€—å·ï¼šä¸ä½œä¸ºä¸»åˆ†éš”ç¬¦ï¼Œä¿ç•™åœ¨å¥ä¸­ (é™¤éåç»­é•¿åº¦å¼ºåˆ¶åˆ‡å‰²)
                            const parts = processed.split(/[ã€‚.]\s*|(?<=[ï¼ï¼Ÿï¼›ï¼š!?])\s*/).filter(p => p.trim().length > 0);

                            const finalParts = [];
                            for (const p of parts) {
                                // 3. å¦‚æœåˆ‡å‰²åçš„ç‰‡æ®µä¾ç„¶è¿‡é•¿ (> 30å­—ç¬¦)ï¼Œå¼ºåˆ¶æŒ‰é•¿åº¦å†æ¬¡åˆ‡å‰²
                                if (p.length > 30) {
                                    let remaining = p;
                                    while (remaining.length > 0) {
                                        let cutIndex = 25;
                                        if (remaining.length <= 25) {
                                            cutIndex = remaining.length;
                                        }
                                        else {
                                            // å°è¯•åœ¨é€—å·æˆ–ç©ºæ ¼å¤„æ–­å¥
                                            // ä¼˜å…ˆæ‰¾é€—å·
                                            const lastComma = Math.max(remaining.lastIndexOf('ï¼Œ', 25), remaining.lastIndexOf(',', 25));
                                            const lastSpace = remaining.lastIndexOf(' ', 25);

                                            if (lastComma > 10) {
                                                cutIndex = lastComma; // åˆ‡åœ¨é€—å·å¤„ (é€—å·ä¼šè¢«ä¸¢å¼ƒ)
                                            } else if (lastSpace > 10) {
                                                cutIndex = lastSpace;
                                            }
                                        }
                                        finalParts.push(remaining.substring(0, cutIndex).trim());

                                        // å¦‚æœæ˜¯åœ¨é€—å·å¤„åˆ‡çš„ï¼Œè¦è·³è¿‡è¿™ä¸ªé€—å·
                                        if (remaining[cutIndex] === 'ï¼Œ' || remaining[cutIndex] === ',') {
                                            remaining = remaining.substring(cutIndex + 1).trim();
                                        } else {
                                            remaining = remaining.substring(cutIndex).trim();
                                        }
                                    }
                                } else {
                                    finalParts.push(p);
                                }
                            }
                            return finalParts;
                        };

                        for (const line of scriptLines.value) {
                            if (line.type === 'dialogue') {
                                const buffer = audioMap.get(line.id);
                                if (buffer) {
                                    const trimStart = line.trimStart || 0;
                                    const trimEnd = line.trimEnd || 1;
                                    const duration = buffer.duration * (trimEnd - trimStart);
                                    const totalDuration = duration / (line.speed || 1.0);

                                    const startTime = currentTime + 0.05; // å¯¹åº” exportAudio çš„ 0.05s åç§»

                                    // è·å–åˆ‡å‰²åçš„å­—å¹•ç‰‡æ®µ
                                    const textSegments = splitLongText(line.text);
                                    const totalLength = textSegments.reduce((acc, cur) => acc + cur.length, 0);

                                    let segmentStartTime = startTime;

                                    if (totalLength > 0) {
                                        for (const segment of textSegments) {
                                            // æŒ‰å­—ç¬¦é•¿åº¦æ¯”ä¾‹åˆ†é…æ—¶é—´
                                            const segmentRatio = segment.length / totalLength;
                                            const segmentDuration = totalDuration * segmentRatio;
                                            const segmentEndTime = segmentStartTime + segmentDuration;

                                            srtContent += `${counter}\n`;
                                            srtContent += `${formatTime(segmentStartTime)} --> ${formatTime(segmentEndTime)}\n`;
                                            srtContent += `${segment}\n\n`;

                                            counter++;
                                            segmentStartTime = segmentEndTime;
                                        }
                                    }

                                    currentTime = startTime + totalDuration;
                                }
                                currentTime += (line.break_duration || 0);
                            }
                        }

                        const blob = new Blob([srtContent], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `Unitaleå­—å¹•æ–‡ä»¶_${Date.now()}.srt`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        console.error(e);
                        alert('å¯¼å‡ºSRTå¤±è´¥: ' + e.message);
                    } finally {
                        isExportingAudio.value = false;
                    }
                };

                // è¾…åŠ©å‡½æ•°ï¼šAudioBuffer è½¬ WAV Blob
                function bufferToWave(abuffer, len) {
                    const numOfChan = abuffer.numberOfChannels;
                    const length = len * numOfChan * 2 + 44;
                    const buffer = new ArrayBuffer(length);
                    const view = new DataView(buffer);
                    const channels = [];
                    let i, sample;
                    let offset = 0;
                    let pos = 0;

                    function setUint16(data) { view.setUint16(offset, data, true); offset += 2; }
                    function setUint32(data) { view.setUint32(offset, data, true); offset += 4; }

                    setUint32(0x46464952); // "RIFF"
                    setUint32(length - 8); // file length - 8
                    setUint32(0x45564157); // "WAVE"
                    setUint32(0x20746d66); // "fmt " chunk
                    setUint32(16); // length = 16
                    setUint16(1); // PCM (uncompressed)
                    setUint16(numOfChan);
                    setUint32(abuffer.sampleRate);
                    setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
                    setUint16(numOfChan * 2); // block-align
                    setUint16(16); // 16-bit
                    setUint32(0x61746164); // "data" - chunk
                    setUint32(length - offset - 4); // chunk length

                    for (i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));

                    while (pos < len) {
                        for (i = 0; i < numOfChan; i++) {
                            sample = Math.max(-1, Math.min(1, channels[i][pos]));
                            sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
                            view.setInt16(offset, sample, true);
                            offset += 2;
                        }
                        pos++;
                    }
                    return new Blob([buffer], { type: "audio/wav" });
                }

                // --- è„šæœ¬åˆ¶ä½œé€»è¾‘ ---
                const splitScript = () => {
                    if (!rawScript.value.trim()) return alert('è¯·è¾“å…¥åŸæ–‡å†…å®¹');

                    let text = rawScript.value.replace(/\r\n/g, '\n');
                    const splitRegex = /\n+|(?<=[ã€‚ï¼ï¼Ÿ!?])(?=["']?)\s*/;

                    const lines = text.split(splitRegex)
                        .map(l => l.trim())
                        .filter(l => l.length > 0);

                    scriptLines.value = lines.map(text => ({
                        id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                        type: 'dialogue',
                        role: 'æ—ç™½',
                        emotion: 'å¹³é™',
                        intensity: 'ä¸­ç­‰',
                        filter: '',
                        text: text,
                        trimStart: 0,
                        trimEnd: 1,
                        sfxVolume: 0.5,
                        dialogueVolume: 1.0,
                        speed: 1.0,
                        audioUrl: '',
                        isGenerating: false
                    }));
                };

                const addBgmBlock = () => {
                    const newBlock = {
                        id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                        type: 'bgm',
                        action: 'play',
                        volume: 0.4,
                        bgmName: bgmLibrary.value.length > 0 ? bgmLibrary.value[0].name : ''
                    };
                    if (selectedLineIndex.value !== -1 && selectedLineIndex.value < scriptLines.value.length) {
                        scriptLines.value.splice(selectedLineIndex.value + 1, 0, newBlock);
                        selectedLineIndex.value++;
                    } else {
                        scriptLines.value.push(newBlock);
                        selectedLineIndex.value = scriptLines.value.length - 1;
                    }
                };

                const addDialogueBlock = () => {
                    const newBlock = {
                        id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                        type: 'dialogue',
                        role: 'æ—ç™½',
                        emotion: 'å¹³é™',
                        intensity: 'ä¸­ç­‰',
                        filter: '',
                        text: '',
                        trimStart: 0,
                        trimEnd: 1,
                        sfx: [],
                        break_duration: 0,
                        sfxVolume: 0.5,
                        dialogueVolume: 1.0,
                        speed: 1.0,
                        audioUrl: '',
                        isGenerating: false
                    };
                    if (selectedLineIndex.value !== -1 && selectedLineIndex.value < scriptLines.value.length) {
                        scriptLines.value.splice(selectedLineIndex.value + 1, 0, newBlock);
                        selectedLineIndex.value++;
                    } else {
                        scriptLines.value.push(newBlock);
                        selectedLineIndex.value = scriptLines.value.length - 1;
                    }
                };

                const removeScriptLine = (index) => {
                    scriptLines.value.splice(index, 1);
                    if (selectedLineIndex.value === index) {
                        selectedLineIndex.value = -1;
                    } else if (selectedLineIndex.value > index) {
                        selectedLineIndex.value--;
                    }
                };

                const autoResizeTextarea = (event) => {
                    const el = event.target;
                    el.style.height = 'auto';
                    el.style.height = el.scrollHeight + 'px';
                };

                const addLineSfx = (line) => {
                    if (!line.sfx) line.sfx = [];
                    const defaultSfx = sfxLibrary.value.length > 0 ? sfxLibrary.value[0].name : 'New SFX';
                    line.sfx.push({ name: defaultSfx, position: 0.5, volume: 0.5, trimStart: 0, trimEnd: 1 });
                };

                const removeLineSfx = (line, index) => {
                    if (line.sfx) line.sfx.splice(index, 1);
                };

                const stopScriptSequentially = () => {
                    isSequencePlaying.value = false;
                    currentSequenceIndex.value = -1;
                    // Stop dialogue audio
                    if (dialogueSource) {
                        try { dialogueSource.stop(); } catch (e) { }
                        dialogueSource = null;
                    }
                    // Stop SFX audio
                    sfxSources.forEach(source => { try { source.stop(); } catch (e) { } });
                    sfxSources = [];
                    // Stop BGM audio
                    if (bgmAudioNode && bgmGainNode) {
                        const oldNode = bgmAudioNode;
                        const oldGain = bgmGainNode;
                        const now = audioContext.currentTime;
                        oldGain.gain.cancelScheduledValues(now);
                        oldGain.gain.setValueAtTime(oldGain.gain.value, now);
                        oldGain.gain.linearRampToValueAtTime(0, now + 2);
                        setTimeout(() => { try { oldNode.stop(); } catch (e) { } }, 2000);
                        bgmAudioNode = null;
                        bgmGainNode = null;
                    }
                };

                const playBgm = async (bgmName, volume = 0.4) => {
                    // Stop any existing BGM
                    if (bgmAudioNode && bgmGainNode) {
                        const oldNode = bgmAudioNode;
                        const oldGain = bgmGainNode;
                        const now = audioContext.currentTime;

                        // æ·¡å‡ºæ—§ BGM
                        oldGain.gain.cancelScheduledValues(now);
                        oldGain.gain.setValueAtTime(oldGain.gain.value, now);
                        oldGain.gain.linearRampToValueAtTime(0, now + 2);

                        setTimeout(() => {
                            try { oldNode.stop(); } catch (e) { }
                        }, 2000);

                        bgmAudioNode = null;
                        bgmGainNode = null;
                    }

                    const bgmLibItem = bgmLibrary.value.find(b => b.name === bgmName);
                    if (!bgmLibItem || !bgmLibItem.filename) {
                        console.warn(`BGM not found in library: ${bgmName}`);
                        return;
                    }

                    try {
                        const audioBuffer = await loadAudioBuffer(bgmLibItem.filename);
                        if (!audioBuffer) throw new Error('Load failed');

                        bgmAudioNode = audioContext.createBufferSource();
                        bgmAudioNode.buffer = audioBuffer;
                        bgmAudioNode.loop = true;

                        bgmGainNode = audioContext.createGain();
                        // æ·¡å…¥æ–° BGM
                        bgmGainNode.gain.value = 0;
                        bgmGainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 2);

                        bgmAudioNode.connect(bgmGainNode).connect(audioContext.destination);
                        bgmAudioNode.start();
                    } catch (e) {
                        console.error(`Failed to load or play BGM ${bgmLibItem.filename}:`, e);
                        alert(`æ’­æ”¾èƒŒæ™¯éŸ³ä¹å¤±è´¥: ${bgmLibItem.filename}`);
                    }
                };

                const playScriptSequentially = async () => {
                    stopScriptSequentially();
                    isSequencePlaying.value = true;
                    const startIndex = selectedLineIndex.value !== -1 ? selectedLineIndex.value : 0;

                    // --- BGM Pre-scan Logic ---
                    if (startIndex > 0) {
                        // Find the last BGM directive before the start index.
                        let lastBgmLine = null;
                        for (let i = startIndex - 1; i >= 0; i--) {
                            const line = scriptLines.value[i];
                            if (line.type === 'bgm') {
                                lastBgmLine = line;
                                break; // Found the last one, no need to look further back.
                            }
                        }

                        // If the last directive was to play a BGM, play it now.
                        // If it was 'stop' or null, we do nothing, as stopScriptSequentially() already handled it.
                        if (lastBgmLine && lastBgmLine.action === 'play') {
                            await playBgm(lastBgmLine.bgmName, lastBgmLine.volume);
                        }
                    }
                    // --- End BGM Pre-scan ---

                    for (let i = startIndex; i < scriptLines.value.length; i++) {
                        if (!isSequencePlaying.value) break; // Check if stopped

                        currentSequenceIndex.value = i;

                        // Scroll into view manually to prevent page scroll
                        const container = scriptListContainer.value;
                        const child = lineRefs.value[i];

                        if (container && child) {
                            const containerRect = container.getBoundingClientRect();
                            const childRect = child.getBoundingClientRect();

                            // The offset of the child relative to the container's top edge
                            const childOffsetTop = childRect.top - containerRect.top;

                            // The desired scrollTop to center the child
                            const newScrollTop = container.scrollTop + childOffsetTop - (container.clientHeight / 2) + (child.clientHeight / 2);

                            container.scrollTo({
                                top: newScrollTop,
                                behavior: 'smooth'
                            });
                        }

                        const line = scriptLines.value[i];

                        if (line.type === 'bgm') {
                            if (line.action === 'play') {
                                await playBgm(line.bgmName, line.volume);
                            } else if (line.action === 'stop') {
                                if (bgmAudioNode && bgmGainNode) {
                                    const oldNode = bgmAudioNode;
                                    const oldGain = bgmGainNode;
                                    const now = audioContext.currentTime;
                                    oldGain.gain.cancelScheduledValues(now);
                                    oldGain.gain.setValueAtTime(oldGain.gain.value, now);
                                    oldGain.gain.linearRampToValueAtTime(0, now + 2);
                                    setTimeout(() => { try { oldNode.stop(); } catch (e) { } }, 2000);
                                    bgmAudioNode = null;
                                    bgmGainNode = null;
                                }
                            }
                        } else { // 'dialogue'
                            if (!line.audioUrl) {
                                // è·³è¿‡æœªç”Ÿæˆçš„å°è¯
                                continue;
                            }

                            // A promise that resolves when the line finishes playing
                            await playLineAudio(line, false);

                            if (!isSequencePlaying.value) break;

                            // Handle break duration
                            if (line.break_duration > 0) {
                                await new Promise(resolve => setTimeout(resolve, line.break_duration * 1000));
                            }
                        }
                    }

                    // Reset when done or stopped
                    stopScriptSequentially();
                };

                const analyzeScript = async () => {
                    if (isAnalyzingScript.value) {
                        if (analysisAbortController.value) analysisAbortController.value.abort();
                        isAnalyzingScript.value = false;
                        return;
                    }

                    if (!currentConfig.value) return alert('è¯·å…ˆåœ¨â€œæ¨¡å‹é…ç½®â€é€‰æ‹©ä¸€ä¸ª LLM æ¨¡å‹é…ç½®');
                    if (!rawScript.value.trim()) return alert('è¯·è¾“å…¥åŸæ–‡å†…å®¹');

                    isAnalyzingScript.value = true;
                    analysisAbortController.value = new AbortController();

                    let sfxSection = "";
                    const enabledSfx = sfxLibrary.value.filter(s => s.enabled !== false);

                    if (enabledSfx.length > 0) {
                        const sfxList = enabledSfx.map(s => `- ${s.name}: ${s.description}`).join('\n');
                        sfxSection = `# éŸ³æ•ˆåº“ (Sound Effects)\nä½ è¿˜å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ç°æœ‰ç´ æï¼š\n${sfxList}\n**æç¤ºï¼šé™¤äº†ä¸Šè¿°ç°æœ‰éŸ³æ•ˆï¼Œå¦‚æœä½ è§‰å¾—å‰§æƒ…æœ‰å…¶ä»–éœ€è¦ï¼Œä¹Ÿå®Œå…¨å¯ä»¥è‡ªå·±ç¼–é€ ç²¾è¾Ÿçš„éŸ³æ•ˆåç§°ï¼ˆå¦‚â€œå¼€é—¨å£°â€ã€â€œçˆ†ç‚¸å£°â€ï¼‰ï¼Œæˆ‘ä»¬éšåå°†åˆ©ç”¨æ¨¡å‹è‡ªåŠ¨ç”Ÿæˆï¼ç»å¯¹ç¦æ­¢ä½¿ç”¨ BGM åº“ä¸­çš„åç§°ã€‚**`;
                    } else {
                        sfxSection = `# éŸ³æ•ˆåº“ (Sound Effects)\nå½“å‰éŸ³æ•ˆåº“ä¸ºç©ºã€‚\n**æç¤ºï¼šåªè¦å‰§æƒ…éœ€è¦ï¼Œä½ å®Œå…¨å¯ä»¥è‡ªå·±æå‡ºéœ€è¦çš„éŸ³æ•ˆå¹¶ç¼–é€ ç²¾è¾Ÿçš„éŸ³æ•ˆåç§°ï¼ˆå¦‚â€œæ‹”å‰‘å£°â€ã€â€œé£å£°â€ï¼‰ï¼Œæˆ‘ä»¬åœ¨åç»­ä¼šå¸®ä½ åˆ©ç”¨æ¨¡å‹è‡ªåŠ¨ç”Ÿæˆå¯¹åº”éŸ³æ•ˆï¼**`;
                    }

                    let bgmSection = "";
                    const enabledBgm = bgmLibrary.value.filter(b => b.enabled !== false);
                    if (enabledBgm.length > 0) {
                        const bgmList = enabledBgm.map(s => `- ${s.name}: ${s.description}`).join('\n');
                        bgmSection = `# èƒŒæ™¯éŸ³ä¹åº“ (Background Music)\nç°æœ‰ä»¥ä¸‹èƒŒæ™¯éŸ³ä¹ç´ æå¯ç”¨ï¼š\n${bgmList}\n\n**æ ¸å¿ƒæŒ‡ä»¤ï¼š**\n1. å¿…é¡»**é€å­—åŒ¹é…**ä½¿ç”¨åˆ—è¡¨ä¸­çš„åç§°ã€‚\n2. å¦‚æœåˆ—è¡¨ä¸­æ²¡æœ‰é€‚åˆå½“å‰å‰§æƒ…çš„éŸ³ä¹ï¼Œ**è¯·å‹¿ç”Ÿæˆ** BGM æ’­æ”¾æŒ‡ä»¤ã€‚\n3. **ä¸¥ç¦ç¼–é€ **åˆ—è¡¨ä¸­ä¸å­˜åœ¨çš„ BGM åç§°ã€‚\n4. **ç»å¯¹ç¦æ­¢**ä½¿ç”¨ SFX åº“ä¸­çš„åç§°ã€‚`;
                    } else {
                        bgmSection = `# èƒŒæ™¯éŸ³ä¹åº“ (Background Music)\n**å½“å‰èƒŒæ™¯éŸ³ä¹åº“ä¸ºç©º (EMPTY)ã€‚**\n\n**æ ¸å¿ƒæŒ‡ä»¤ï¼š**\n1. **ä¸¥ç¦ç”Ÿæˆ**ä»»ä½• action="play" çš„ BGM æ§åˆ¶å—ã€‚\n2. ä½ åªèƒ½ç”Ÿæˆ action="stop" çš„æŒ‡ä»¤ï¼ˆå¦‚æœéœ€è¦åœæ­¢ä¹‹å‰çš„éŸ³ä¹ï¼‰ã€‚\n3. ç»å¯¹ä¸è¦ç¼–é€  BGM åç§°ã€‚`;
                    }

                    let filterSection = "";
                    const enabledFilters = filterLibrary.value.filter(f => f.enabled !== false);
                    if (enabledFilters.length > 0) {
                        const fList = enabledFilters.map(f => `- ${f.name}: ${f.description}`).join('\n');
                        filterSection = `# æ»¤æ³¢å™¨åº“ (Audio Filters)\nå¦‚æœå‰§æƒ…éœ€è¦ç‰¹æ®ŠéŸ³æ•ˆå¤„ç†ï¼ˆå¦‚ç”µè¯ã€æ°´ä¸‹ã€å›å¿†ï¼‰ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹æ»¤æ³¢å™¨ï¼š\n${fList}\n**æ³¨æ„ï¼šå¿…é¡»ä¸¥æ ¼ä½¿ç”¨åˆ—è¡¨ä¸­çš„åç§°ï¼Œå¦‚æœæ²¡æœ‰åŒ¹é…é¡¹åˆ™ä¸è¦ä½¿ç”¨ filter å­—æ®µã€‚**`;
                    } else {
                        filterSection = `# æ»¤æ³¢å™¨åº“ (Audio Filters)\nå½“å‰æ»¤æ³¢å™¨åº“ä¸ºç©ºã€‚\n**æ³¨æ„ï¼šè¯·å‹¿ç”Ÿæˆä»»ä½• filter å­—æ®µã€‚**`;
                    }

                    const emotionList = emotionPresets.value.filter(e => e.enabled !== false).map(e => e.name).join(', ');

                    const bgmExampleLine = enabledBgm.length > 0
                        ? `{"type": "bgm", "action": "play", "name": "${enabledBgm[0].name}"},`
                        : '';

                    const sfxExample = enabledSfx.length > 0
                        ? `, "sfx": [{"name": "${enabledSfx[0].name}", "position": 0.2, "trimStart": 0, "trimEnd": 1, "volume": 0.5}]`
                        : '';

                    const templateToUse = useCustomPrompt.value ? customPromptTemplate.value : defaultPromptTemplate;
                    let finalPrompt = templateToUse
                        .replace(/\${emotionList}/g, emotionList)
                        .replace(/\${sfxSection}/g, sfxSection)
                        .replace(/\${bgmSection}/g, bgmSection)
                        .replace(/\${filterSection}/g, filterSection)
                        .replace(/\${bgmExampleLine}/g, bgmExampleLine)
                        .replace(/\${sfxExample}/g, sfxExample)
                        .replace(/\${rawScript}/g, rawScript.value);

                    try {
                        const cfg = currentConfig.value;
                        let url = cfg.baseUrl.trim().replace(/\/+$/, '');
                        if (!url.endsWith('/chat/completions')) url += '/chat/completions';

                        let body = { model: cfg.model, messages: [{ role: 'user', content: finalPrompt }], stream: false };

                        if (cfg.params) {
                            try {
                                const extraParams = JSON.parse(cfg.params);
                                body = { ...body, ...extraParams };
                            } catch (e) {
                                console.warn('è§£æé¢å¤–å‚æ•°å¤±è´¥:', e);
                            }
                        }

                        const res = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${cfg.key}` },
                            body: JSON.stringify(body),
                            signal: analysisAbortController.value.signal
                        });

                        if (!res.ok) throw new Error(`HTTP ${res.status}`);

                        const data = await res.json();
                        const content = data.choices[0]?.message?.content || '';
                        rawAnalysisResult.value = content; // ä¿å­˜åŸå§‹è¾“å‡º
                        const jsonMatch = content.match(/\[\s*\{[\s\S]*\}\s*\]/);
                        const jsonStr = jsonMatch ? jsonMatch[0] : content.replace(/```json/g, '').replace(/```/g, '').trim();

                        const parsed = JSON.parse(jsonStr);
                        if (Array.isArray(parsed)) {
                            // ç§»é™¤æ‹¦æˆªé€»è¾‘ï¼Œå®Œå…¨ä¿¡ä»» Prompt (æˆ–å…è®¸ç”¨æˆ·æ‰‹åŠ¨ä¿®æ­£å¹»è§‰)
                            const validParsed = parsed;

                            const newRoles = new Set();
                            validParsed.forEach(item => {
                                const r = item.role_name || item.role;
                                if (r) newRoles.add(r);
                            });

                            // é‡æ–°æ„å»ºè§’è‰²åˆ—è¡¨ï¼šæ¸…ç©ºå¹¶å¡«å…… (ä¿ç•™å·²æœ‰è§’è‰²çš„éŸ³è‰²é…ç½®)
                            const newCharacterList = [];
                            newRoles.forEach(rName => {
                                const existing = characters.value.find(c => c.name === rName);
                                let voiceFile = '';
                                let id = Date.now() + Math.random().toString();

                                if (existing) {
                                    voiceFile = existing.voiceFile;
                                    id = existing.id;
                                } else {
                                    const matchingTimbre = timbres.value.find(t => t.name === rName);
                                    if (matchingTimbre) voiceFile = matchingTimbre.refPath;
                                }

                                newCharacterList.push({
                                    id: id,
                                    name: rName,
                                    voiceFile: voiceFile
                                });
                            });
                            characters.value = newCharacterList;

                            scriptLines.value = validParsed.map(item => {
                                // é€šç”¨æ¨¡ç³ŠåŒ¹é…å‡½æ•°
                                const findBestMatch = (target, library) => {
                                    if (!target) return '';
                                    const t = target.trim().toLowerCase();
                                    // 1. ç²¾ç¡®åŒ¹é…
                                    const exact = library.find(i => i.name.toLowerCase() === t);
                                    if (exact) return exact.name;

                                    // 2. æ¨¡ç³ŠåŒ¹é… (åŒ…å«å…³ç³»)
                                    const candidates = library.filter(i => {
                                        const n = i.name.toLowerCase();
                                        return n.includes(t) || t.includes(n);
                                    });

                                    if (candidates.length > 0) {
                                        // æŒ‰é•¿åº¦å·®æ’åºï¼Œæ‰¾æœ€æ¥è¿‘çš„
                                        candidates.sort((a, b) => Math.abs(a.name.length - target.length) - Math.abs(b.name.length - target.length));
                                        return candidates[0].name;
                                    }
                                    return '';
                                };

                                // 1. åŒ¹é…æ»¤æ³¢å™¨
                                let matchedFilter = '';
                                if (item.filter) {
                                    matchedFilter = findBestMatch(item.filter, filterLibrary.value);
                                }

                                // 2. åŒ¹é…éŸ³æ•ˆ
                                let matchedSfx = [];
                                if (item.sfx && Array.isArray(item.sfx)) {
                                    matchedSfx = item.sfx.map(s => ({
                                        name: findBestMatch(s.name, sfxLibrary.value) || s.name,
                                        position: s.position,
                                        trimStart: typeof s.trimStart === 'number' ? s.trimStart : 0,
                                        trimEnd: typeof s.trimEnd === 'number' ? s.trimEnd : 1,
                                        volume: typeof s.volume === 'number' ? s.volume : 0.5
                                    }));
                                }

                                // 3. åŒ¹é… BGM
                                let matchedBgmName = '';
                                if (item.type === 'bgm' && item.action === 'play') {
                                    const rawName = item.name || item.bgmName || '';
                                    matchedBgmName = findBestMatch(rawName, bgmLibrary.value) || rawName;
                                }

                                return {
                                    id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                                    type: item.type || 'dialogue',
                                    // Dialogue fields
                                    role: item.role_name || item.role || 'æ—ç™½',
                                    text: item.text_content || item.text || item.content || '',
                                    emotion: item.emotion || 'å¹³é™',
                                    intensity: item.intensity || 'ä¸­ç­‰',
                                    filter: matchedFilter,
                                    sfx: matchedSfx,
                                    break_duration: typeof item.break_duration === 'number' ? item.break_duration : 0,
                                    trimStart: 0,
                                    trimEnd: 1,
                                    sfxVolume: 0.5,
                                    dialogueVolume: 1.0,
                                    audioUrl: '',
                                    isGenerating: false,
                                    // BGM fields
                                    action: item.action || 'play',
                                    volume: 0.4,
                                    bgmName: matchedBgmName
                                };
                            });
                        } else {
                            alert('AI è¿”å›æ ¼å¼å¼‚å¸¸ï¼Œè¯·é‡è¯•');
                        }
                    } catch (e) {
                        if (e.name === 'AbortError') {
                            alert('åˆ†æå·²åœæ­¢');
                        } else {
                            console.error(e);
                            alert('åˆ†æå¤±è´¥: ' + e.message);
                        }
                    } finally {
                        isAnalyzingScript.value = false;
                        analysisAbortController.value = null;
                    }
                };


                // --- èŠå¤©é€»è¾‘ ---
                const clearAll = () => {
                    result.value = '';
                    reasoning.value = '';
                    error.value = '';
                };

                const stopGeneration = () => {
                    if (abortController.value) {
                        abortController.value.abort();
                        abortController.value = null;
                        loading.value = false;
                    }
                };

                const send = async () => {
                    if (!currentConfig.value) return alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæœ‰æ•ˆçš„æ¨¡å‹é…ç½®');
                    const cfg = currentConfig.value;

                    loading.value = true;
                    result.value = '';
                    reasoning.value = '';
                    error.value = '';

                    abortController.value = new AbortController();

                    try {
                        let url = cfg.baseUrl.trim().replace(/\/+$/, '');

                        if (!url.endsWith('/chat/completions')) {
                            url += '/chat/completions';
                        }

                        let body = {
                            model: cfg.model,
                            messages: [{ role: 'user', content: prompt.value }],
                            stream: true
                        };

                        if (cfg.params) {
                            try {
                                const extraParams = JSON.parse(cfg.params);
                                body = { ...body, ...extraParams };
                            } catch (e) {
                                console.warn('è§£æé¢å¤–å‚æ•°å¤±è´¥:', e);
                            }
                        }

                        const res = await fetch(url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${cfg.key}`
                            },
                            body: JSON.stringify(body),
                            signal: abortController.value.signal
                        });

                        if (!res.ok) {
                            const errData = await res.text();
                            throw new Error(`HTTP ${res.status}: ${errData}`);
                        }

                        const reader = res.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = "";

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop(); // ä¿æŒæœ€åä¸€è¡Œå®Œæ•´

                            for (const line of lines) {
                                const cleanLine = line.replace(/^data: /, '').trim();
                                if (!cleanLine || cleanLine === '[DONE]') continue;

                                try {
                                    const json = JSON.parse(cleanLine);
                                    const delta = json.choices[0]?.delta;

                                    if (delta?.reasoning_content) {
                                        reasoning.value += delta.reasoning_content;
                                    }
                                    if (delta?.content) {
                                        result.value += delta.content;
                                    }
                                } catch (e) {
                                    // å¿½ç•¥éƒ¨åˆ†è§£æé”™è¯¯
                                }
                            }
                        }
                    } catch (e) {
                        if (e.name === 'AbortError') {
                            // ç”¨æˆ·æ‰‹åŠ¨åœæ­¢ï¼Œä¸æŠ¥é”™
                        } else {
                            error.value = e.message;
                            if (e.message.includes('Failed to fetch')) {
                                error.value += "\n\næ£€æµ‹åˆ°è·¨åŸŸ(CORS)é™åˆ¶ï¼Gemini API é€šå¸¸ç¦æ­¢ä»æµè§ˆå™¨å‰ç«¯ç›´æ¥è°ƒç”¨ã€‚\nå»ºè®®ï¼šå¼€å¯æµè§ˆå™¨ CORS æ’ä»¶ï¼Œæˆ–ä½¿ç”¨åç«¯ä¸­è½¬ã€‚";
                            }
                        }
                    } finally {
                        loading.value = false;
                        abortController.value = null;
                    }
                };

                // --- TTS é€»è¾‘ (SonicVale åè®®) ---

                const handleFileUpload = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        ttsRefFile.value = file;
                        if (!ttsRefPath.value || ttsRefPath.value === 'uploaded/ref.wav') {
                            ttsRefPath.value = `uploaded/${file.name}`;
                        }
                    }
                };

                const stopTtsGeneration = () => {
                    if (ttsAbortController.value) {
                        ttsAbortController.value.abort();
                        ttsAbortController.value = null;
                        ttsLoading.value = false;
                    }
                };

                const synthesizeAudio = async () => {
                    if (!currentTtsConfig.value) return alert('è¯·é€‰æ‹© TTS é…ç½®');
                    const textToSpeak = result.value || prompt.value;
                    if (!textToSpeak) return alert('æ²¡æœ‰å¯åˆæˆçš„æ–‡æœ¬ (è¯·å…ˆå¯¹è¯æˆ–è¾“å…¥æç¤ºè¯)');
                    if (!ttsRefPath.value) return alert('è¯·æŒ‡å®šå‚è€ƒéŸ³é¢‘è·¯å¾„ ID');

                    ttsLoading.value = true;
                    ttsError.value = '';
                    audioUrl.value = '';

                    ttsAbortController.value = new AbortController();

                    const cfg = currentTtsConfig.value;
                    let baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');
                    if (baseUrl.endsWith('/v1')) baseUrl = baseUrl.slice(0, -3);

                    try {
                        // 1. æ£€æŸ¥éŸ³é¢‘æ˜¯å¦å­˜åœ¨
                        const checkUrl = `${baseUrl}/v1/check/audio?file_name=${encodeURIComponent(ttsRefPath.value)}`;
                        const checkRes = await fetch(checkUrl, { signal: ttsAbortController.value.signal });
                        if (!checkRes.ok) throw new Error(`Check failed: ${checkRes.status}`);
                        const checkData = await checkRes.json();

                        // 2. ä¸Šä¼ é€»è¾‘ï¼šå¦‚æœç”¨æˆ·é€‰æ‹©äº†æ–‡ä»¶ï¼Œå¼ºåˆ¶ä¸Šä¼ ï¼ˆè¦†ç›–ï¼‰ï¼›å¦åˆ™æ£€æŸ¥æœåŠ¡ç«¯æ˜¯å¦å­˜åœ¨
                        // ä¿®æ”¹ï¼šå³ä½¿æœåŠ¡ç«¯å­˜åœ¨ï¼Œåªè¦ç”¨æˆ·é€‰äº†æ–°æ–‡ä»¶ï¼Œå°±å¼ºåˆ¶ä¸Šä¼ ï¼Œé˜²æ­¢æ–‡ä»¶å†…å®¹ä¸ä¸€è‡´æˆ–æœåŠ¡ç«¯æ–‡ä»¶æŸå
                        if (ttsRefFile.value) {
                            const formData = new FormData();
                            formData.append('audio', ttsRefFile.value);
                            formData.append('full_path', ttsRefPath.value);

                            const uploadRes = await fetch(`${baseUrl}/v1/upload_audio`, {
                                method: 'POST',
                                body: formData,
                                signal: ttsAbortController.value.signal
                            });

                            if (!uploadRes.ok) throw new Error(`Upload failed: ${uploadRes.status}`);
                        } else if (!checkData.exists) {
                            throw new Error(`æœåŠ¡ç«¯æœªæ‰¾åˆ°éŸ³é¢‘ "${ttsRefPath.value}"ï¼Œä¸”æœªé€‰æ‹©æœ¬åœ°æ–‡ä»¶è¿›è¡Œä¸Šä¼ ã€‚`);
                        }

                        // 3. åˆæˆè¯­éŸ³
                        const synthPayload = {
                            text: textToSpeak,
                            audio_path: ttsRefPath.value,
                            emo_text: ttsEmoText.value || 'ä¸­ç«‹'
                        };

                        const synthRes = await fetch(`${baseUrl}/v2/synthesize`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(synthPayload),
                            signal: ttsAbortController.value.signal
                        });

                        if (!synthRes.ok) {
                            const errText = await synthRes.text();
                            throw new Error(`Synthesis failed: ${errText}`);
                        }

                        // 4. å¤„ç†äºŒè¿›åˆ¶éŸ³é¢‘æµ
                        const blob = await synthRes.blob();
                        audioUrl.value = URL.createObjectURL(blob);

                    } catch (e) {
                        if (e.name === 'AbortError') {
                            // ç”¨æˆ·æ‰‹åŠ¨åœæ­¢
                        } else {
                            console.error(e);
                            ttsError.value = e.message;
                        }
                    } finally {
                        ttsLoading.value = false;
                        ttsAbortController.value = null;
                    }
                };

                const savePrompt = () => {
                    localStorage.setItem('storyforge_prompt_template', customPromptTemplate.value);
                    localStorage.setItem('storyforge_use_custom_prompt', JSON.stringify(useCustomPrompt.value));
                    localStorage.setItem('storyforge_voice_prompt_template', customVoicePromptTemplate.value);
                    localStorage.setItem('storyforge_use_custom_voice_prompt', JSON.stringify(useCustomVoicePrompt.value));
                    alert('Prompt è®¾ç½®å·²ä¿å­˜');
                };

                const saveVoicePrompt = () => {
                    localStorage.setItem('storyforge_voice_prompt_template', customVoicePromptTemplate.value);
                    localStorage.setItem('storyforge_use_custom_voice_prompt', JSON.stringify(useCustomVoicePrompt.value));
                    alert('éŸ³è‰²åˆ†æ Prompt è®¾ç½®å·²ä¿å­˜');
                };

                const resetPrompt = () => {
                    if (confirm('ç¡®å®šè¦æ¢å¤é»˜è®¤ Prompt å—ï¼Ÿ')) {
                        customPromptTemplate.value = defaultPromptTemplate;
                        customVoicePromptTemplate.value = defaultVoicePromptTemplate;
                    }
                };

                const resetVoicePrompt = () => {
                    if (confirm('ç¡®å®šè¦æ¢å¤é»˜è®¤çš„éŸ³è‰²åˆ†æ Prompt å—ï¼Ÿ')) {
                        customVoicePromptTemplate.value = defaultVoicePromptTemplate;
                        localStorage.setItem('storyforge_voice_prompt_template', defaultVoicePromptTemplate);
                    }
                };

                const saveQwenVoiceText = () => {
                    localStorage.setItem('storyforge_qwen_voice_text_template', customQwenVoiceTextTemplate.value);
                    localStorage.setItem('storyforge_use_custom_qwen_voice_text', JSON.stringify(useCustomQwenVoiceText.value));
                    alert('Qwen ç”Ÿæˆæ–‡æœ¬è®¾ç½®å·²ä¿å­˜');
                };

                const resetQwenVoiceText = () => {
                    if (confirm('ç¡®å®šè¦æ¢å¤é»˜è®¤æ–‡æœ¬å—ï¼Ÿ')) {
                        customQwenVoiceTextTemplate.value = defaultQwenVoiceTextTemplate;
                    }
                };

                // ç›‘å¬å¼€å…³çŠ¶æ€ï¼Œå®æ—¶ä¿å­˜
                watch(useCustomPrompt, (newVal) => {
                    localStorage.setItem('storyforge_use_custom_prompt', JSON.stringify(newVal));
                });

                watch(useCustomVoicePrompt, (newVal) => {
                    localStorage.setItem('storyforge_use_custom_voice_prompt', JSON.stringify(newVal));
                });

                watch(useCustomQwenVoiceText, (newVal) => {
                    localStorage.setItem('storyforge_use_custom_qwen_voice_text', JSON.stringify(newVal));
                });

                return {
                    // State
                    activeTab, llmConfigs, currentConfigId,
                    form, isEditing,
                    filterLibrary, filterForm, isEditingFilter, saveFilter, editFilter, deleteFilter, resetFilterForm,
                    prompt, result, reasoning, error, loading,

                    // TTS State
                    currentTtsConfigId, ttsConfigs, ttsRefPath, ttsEmoText,
                    audioUrl, ttsLoading, ttsError,

                    // TTS Actions
                    handleFileUpload, synthesizeAudio, stopTtsGeneration,

                    // Actions
                    saveConfig, editConfig, deleteConfig, resetForm,
                    // TTS Actions
                    ttsForm, isEditingTts,
                    saveTtsConfig, editTtsConfig, deleteTtsConfig, resetTtsForm,

                    // Character Actions (New)
                    characters, addCharacter, deleteCharacter,
                    analyzeCharacterVoice, generateQwenVoice, generateMossVoice,
                    isRecordModalOpen, recordTargetChar, recordState, recordAudioBuffer, recordTrimStart, recordTrimEnd,
                    isSavingRecord, openVoiceRecordModal, closeRecordModal, handleUploadVoice, startRecording, stopRecording,
                    playTrimmedRecord, stopTrimmedRecord, saveRecordAndTrim, recordWaveformCanvas, drawRecordWaveform,

                    // Timbre Actions
                    timbres, timbreForm, isEditingTimbre, selectedTimbreId,
                    saveTimbre, editTimbre, deleteTimbre, resetTimbreForm, handleTimbreFileUpload,

                    // Emotion Actions
                    emotionPresets, emotionForm, isEditingEmotion,
                    saveEmotion, editEmotion, deleteEmotion, resetEmotionForm, resetEmotionsToDefault,
                    isSystemEmotion, // Export helper

                    // SFX Actions
                    sfxLibrary, sfxForm, isEditingSfx,
                    saveSfx, editSfx, deleteSfx, resetSfxForm, handleSfxFileUpload,
                    addLineSfx, removeLineSfx,
                    sfxGenForm, isGeneratingSfx, generateSfxWithMoss, generateMissingSfx,

                    // BGM Actions
                    bgmLibrary, bgmForm, isEditingBgm,
                    saveBgm, editBgm, deleteBgm, resetBgmForm, handleBgmFileUpload,

                    // Audition Actions
                    availableRoles, isAuditioningId, generateLineAudio, playLineAudio, clearLineAudio,

                    playPreview, previewPlayingFile,
                    send, stopGeneration, clearAll,

                    playbackProgress, // Export for template

                    // Script Actions
                    rawScript, scriptLines, splitScript, removeScriptLine, autoResizeTextarea, analyzeScript, isAnalyzingScript, rawAnalysisResult,
                    addBgmBlock, addDialogueBlock, selectedLineIndex,
                    drawWaveform, startDragTrim, // Exported for template
                    generateAllLines, isGeneratingAll, clearAllGeneratedAudio,
                    moveLineUp, moveLineDown,
                    toggleLineSelection,
                    exportScriptState, triggerImport, handleImportFile, importFileRef, exportAudio, isExportingAudio,
                    exportSRT, triggerImportTxt, handleImportTxt, importTxtRef,
                    isExportingProject, exportStatus,
                    playScriptSequentially, stopScriptSequentially, isSequencePlaying, currentSequenceIndex,
                    lineRefs,
                    scriptListContainer,

                    customPromptTemplate, useCustomPrompt, savePrompt, resetPrompt,
                    customVoicePromptTemplate, useCustomVoicePrompt, saveVoicePrompt, resetVoicePrompt,
                    customQwenVoiceTextTemplate, useCustomQwenVoiceText, saveQwenVoiceText, resetQwenVoiceText,
                };
            }
        }).mount('#app');
    </script>
</body>

</html>